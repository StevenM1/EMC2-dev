library(usethis)
usethis::create_package()
usethis::use_description()
load_all()
library(devtools)
load_all()
ls("EMC2")
ls("package:EMC2")
lsf.str("package:dplyr")
library(EMC2)
library(EMC2)
check()
check()
install.packages("rtdists")
install.packages("rtdists")
install.packages('rtdists')
rm(list=ls())
load("~/Documents/UVA/2022/EMC_test/PNAS.RData")
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
# head(dat)
# Average and difference matrix
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
#### Models -----
# Mu varies by stimulus, emphasis, and latent match
design_mu <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Clist=list(lM=ADmat,lR=ADmat,E=Emat,S=ADmat),
Flist=list(m~S*E*lM,s~1,t0~1),
model=lnrMS)
load_all()
library(devtools)
rm(list=ls())
load("~/Documents/UVA/2022/EMC_test/PNAS.RData")
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
# head(dat)
# Average and difference matrix
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
#### Models -----
# Mu varies by stimulus, emphasis, and latent match
design_mu <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Clist=list(lM=ADmat,lR=ADmat,E=Emat,S=ADmat),
Flist=list(m~S*E*lM,s~1,t0~1),
model=lnrMS)
load_all()
rm(list=ls())
load("~/Documents/UVA/2022/EMC_test/PNAS.RData")
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
# head(dat)
# Average and difference matrix
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
#### Models -----
# Mu varies by stimulus, emphasis, and latent match
design_mu <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Clist=list(lM=ADmat,lR=ADmat,E=Emat,S=ADmat),
Flist=list(m~S*E*lM,s~1,t0~1),
model=lnrMS)
# Test single subject
dat_single <- dat[which(dat$subjects %in% (unique(dat$subjects)[1])),]
dat_single <- droplevels(dat_single)
samplers <- make_samplers(dat_single, design_mu, type = "single")
samplers <- run_samplers(samplers, stage = "preburn", iter = 200, verbose = T, cores_per_chain = 10, cores_for_chains = 1)
samplers <- make_samplers(dat_single, design_mu, type = "single", n_chains = 1)
samplers <- run_samplers(samplers, stage = "preburn", iter = 200, verbose = T, cores_per_chain = 10, cores_for_chains = 1)
samplers <- run_samplers(samplers, stage = "burn", iter = 1000, verbose = T, cores_per_chain = 10, cores_for_chains = 1)
warnings()
debug(update_progress_bar)
samplers <- run_samplers(samplers, stage = "preburn", iter = 200, verbose = T, cores_per_chain = 10, cores_for_chains = 1)
debug(accept_progress_bar)
samplers <- run_samplers(samplers, stage = "preburn", iter = 200, verbose = T, cores_per_chain = 10, cores_for_chains = 1)
?gettextf
width
samplers <- run_samplers(samplers, stage = "preburn", iter = 200, verbose = T, cores_per_chain = 10, cores_for_chains = 1)
nchar(lapply(component, gettextf, 100), "w")
load_all()
debug(accept_progress_bar)
samplers <- run_samplers(samplers, stage = "preburn", iter = 200, verbose = T, cores_per_chain = 10, cores_for_chains = 1)
width
undebug(accept_progress_bar)
samplers <- run_samplers(samplers, stage = "preburn", iter = 200, verbose = T, cores_per_chain = 10, cores_for_chains = 1)
samplers <- run_samplers(samplers, stage = "burn", iter = 1000, verbose = T, cores_per_chain = 10, cores_for_chains = 1)
rm(list=ls())
load("~/Documents/UVA/2022/EMC_test/PNAS.RData")
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
# head(dat)
# Average and difference matrix
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
#### Models -----
# Mu varies by stimulus, emphasis, and latent match
design_mu <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Clist=list(lM=ADmat,lR=ADmat,E=Emat,S=ADmat),
Flist=list(m~S*E*lM,s~1,t0~1),
model=lnrMS)
# Test single subject
dat_single <- dat[which(dat$subjects %in% (unique(dat$subjects)[1])),]
dat_single <- droplevels(dat_single)
samplers <- make_samplers(dat_single, design_mu, type = "single", n_chains = 1)
samplers <- run_samplers(samplers, stage = "preburn", iter = 150, verbose = T, cores_per_chain = 10, cores_for_chains = 1)
rm(list=ls())
load("~/Documents/UVA/2022/EMC_test/PNAS.RData")
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
# head(dat)
# Average and difference matrix
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
#### Models -----
# Mu varies by stimulus, emphasis, and latent match
design_mu <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Clist=list(lM=ADmat,lR=ADmat,E=Emat,S=ADmat),
Flist=list(m~S*E*lM,s~1,t0~1),
model=lnrMS)
rm(list=ls())
library(devtools)
load_all()
load("~/Documents/UVA/2022/EMC_test/PNAS.RData")
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
# head(dat)
# Average and difference matrix
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
#### Models -----
# Mu varies by stimulus, emphasis, and latent match
design_mu <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Clist=list(lM=ADmat,lR=ADmat,E=Emat,S=ADmat),
Flist=list(m~S*E*lM,s~1,t0~1),
model=lnrMS)
# Test single subject
dat_single <- dat[which(dat$subjects %in% (unique(dat$subjects)[1])),]
dat_single <- droplevels(dat_single)
samplers <- make_samplers(dat_single, design_mu, type = "single", n_chains = 1)
debug(new_particle)
samplers <- run_samplers(samplers, stage = "preburn", iter = 150, verbose = T, cores_per_chain = 1, cores_for_chains = 1)
debug(likelihood_func)
debug(log_likelihood_race)
debug(get_pars)
debug(map_p)
map_p(
attr(dadm,"model")()$transform(add_constants(p_vector,attr(dadm,"constants"))),
dadm)
p
dadm
length(attr(dadm,"model")()$p_types)
attr(dadm,"designs")[[i]][attr(attr(dadm,"designs")[[i]],"expand"),,drop=FALSE]
p[dimnames(attr(dadm,"designs")[[i]])[[2]]]
(attr(dadm,"designs")[[i]][attr(attr(dadm,"designs")[[i]],"expand"),,drop=FALSE] %*%
p[dimnames(attr(dadm,"designs")[[i]])[[2]]])
<<<<<<< HEAD
=======
library(devtools)
load_all()
load_all()
library(devtools)
load_all()
ls("package:EMC2")
ls("package:EMC2")
gd_pmwg
?as_mcmc
library(coda)
rm(list=ls())
library(devtools)
load_all()
load("~/Documents/UVA/2022/EMC_test/PNAS.RData")
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
# head(dat)
# Average and difference matrix
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
#### Models -----
# Mu varies by stimulus, emphasis, and latent match
design_mu <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Clist=list(lM=ADmat,lR=ADmat,E=Emat,S=ADmat),
Flist=list(m~S*E*lM,s~1,t0~1),
model=lnrMS)
lnrMS
rm(list=ls())
library(devtools)
load_all()
load("~/Documents/UVA/2022/EMC_test/PNAS.RData")
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
# Average and difference matrix
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
# Mu varies by stimulus, emphasis, and latent match
design_mu <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Clist=list(lM=ADmat,lR=ADmat,E=Emat,S=ADmat),
Flist=list(m~S*E*lM,s~1,t0~1),
model=lnrMS)
debug(make_design)
# Mu varies by stimulus, emphasis, and latent match
design_mu <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Clist=list(lM=ADmat,lR=ADmat,E=Emat,S=ADmat),
Flist=list(m~S*E*lM,s~1,t0~1),
model=lnrMS)
>>>>>>> origin/main
# base test
# start from (0,0), stand still for 1sec, then move at 1m/sec, first up 3m then
# right 4m, then stand still for 1sec, samples at 5Hz
xy <- cbind(x=c(rep(0,5),rep(0,3*5-1),seq(0,4,length.out=4*5+1),rep(4,5)),
y=c(rep(0,5),seq(0,3,length.out=3*5),rep(3,4*5),rep(3,5)))
# Path distance by linear interpolation
getdistance <- function(xy) {
sum(sqrt(apply(cbind(diff(xy[,1])^2,diff(xy[,2])^2),1,sum)))
}
# Show path and distance
plotpath <- function(xy,xlim=c(-1,5),ylim=c(-1,4)) {
plot(xy[,1],xy[,2],xlim=xlim,ylim=ylim,
main=paste(round(getdistance(xy),3),"m"))
lines(xy[,1],xy[,2])
}
# add uniform noise to coordinates, if xnoise=ynoise noise is isotropic
addnoise <- function(xy,xnoise=.5,ynoise=.5) {
xy[,1] <- xy[,1] + runif(dim(xy)[1])*xnoise
xy[,2] <- xy[,2] + runif(dim(xy)[1])*ynoise
xy
}
# Smooth path with boxcar width 5
boxsmooth <- function(xy,w=5) {
npts <- dim(xy)[1]
xysmooth <- xy[-c(1:5),]
for (i in 1:(npts-w)) {
xysmooth[i,1] <- mean(xy[i:(i+w-1),1])
xysmooth[i,2] <- mean(xy[i:(i+w-1),2])
}
xysmooth
}
par(mfrow=c(1,3))
# Without noise
plotpath(xy)
# With noise, distance over-estimated
plotpath(addnoise(xy))
# With smooth, distance fairly accurate
plotpath(boxsmooth(addnoise(xy)))
setwd("/Volumes/Data/Projects/EMCpackage/EMC2fork")
# Be in EMC2 directory to load package as follows
devtools::load_all()
devtools::check()
usethis::use_import_from("stats", c("dexp", "pexp", "rexp"))
warnings()
devtools::check()
library(EMC2)
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
# Be in EMC2 directory to load package as follows
devtools::load_all()
library(EMC2)
# NB: Stop *must* be first level of Rlevels
designEXG <- make_design(Flist=list(mu ~ lM, sigma ~ 1, tau ~ 1, muS~1, sigmaS~1, tauS~1, gf~ 1, tf~1),
Ffactors=list(subjects=1,S=c("left","right")),Rlevels=c("stop","left","right"),
matchfun=function(d)as.character(d$S)==as.character(d$lR),
Clist=list(lM=matrix(c(-1/2,1/2),ncol=1),S=contr.helmert),
Fcovariates="SSD",model=SSexGaussian)
p_vector <- sampled_p_vector(design=designEXG,model=SSexGaussian)
p_vector[1:2] <- log(c(.6,.75)) # Intercept and (multiplicative) quality
p_vector[3:4] <- c(log(.05),log(0.1)) # sigma and tau
p_vector[5:7] <- c(log(.2),log(.05),log(0.1)) # muS, sigmaS and tauS
p_vector[8:9] <- c(qnorm(0),qnorm(0))
p_vector[8:9] <- c(qnorm(.05),qnorm(0))
p_vector[8:9] <- c(qnorm(0),qnorm(.1))
p_vector[8:9] <- c(qnorm(.05),qnorm(.1))
# Staircase run where SSD is NA, starting point, step, and min and max SSD
# values controlled by defaults set in model
dataEXG <- make_data(p_vector,design=designEXG,trials=1000)
# # Mixture of three cases
# dataEXG$SSD <- rep(c(rep(Inf,300),rep(c(.1,.2,.3),100),rep(NA,400)),times=2)
# All staircase
dataEXG$SSD <- rep(NA,dim(dataEXG)[1])
dataEXG <- make_data(p_vector,design=designEXG,data=dataEXG)
# Need to specify factors to avoid including SSD
plot_defective_density(dataEXG,layout=c(1,2),factors="S")
# Check get same C and R value
dadm <- design_model(dataEXG,designEXG)
attr(dadm,"model")()$log_likelihood(p_vector,dadm) # [1] 2684.95
n=1000
out <- numeric(n)
system.time({
for (i in 1:n)
out[i] <- attr(dadm,"model")()$log_likelihood(p_vector,dadm)
})
# Load precomptued data ...
print(load("../dataEXG.RData"))
# Check get same C and R value
dadm <- design_model(dataEXG,designEXG)
attr(dadm,"model")()$log_likelihood(p_vector,dadm) # [1] 2684.95
dat_single <- dataEXG[which(dataEXG$subjects %in% (unique(dataEXG$subjects)[1])),]
dat_single <- droplevels(dat_single)
samplers <- make_samplers(dat_single, designEXG, type = "single", n_chains = 1)
system.time({
exgSS1 <- run_samplers(samplers,iter=150,verbose = TRUE, stage = "preburn",
cores_per_chain = 1, cores_for_chains = 1)
})
system.time({
exgSS1 <- run_samplers(samplers,iter=150,verbose = TRUE, stage = "preburn",
cores_per_chain = 8, cores_for_chains = 1)
})
designRDM <- make_design(
Ffactors=list(subjects=1,S=c("left","right")),
Rlevels=c("left","right"),matchfun=function(d)d$S==d$lR,
Clist=list(lM=matrix(c(-1/2,1/2),ncol=1),S=contr.helmert),
Flist=list(v~lM,B~1,A~1,t0~1,s~1),constants=c(s=0),
model=rdmB)
p_vector <- sampled_p_vector(design=designRDM,model=rdmB)
p_vector[1:5] <- log(c(1,2,2,.1,.3))
print(load("../dataRDM.RData"))
# Check get same C and R value
dadm <- design_model(dataRDM,designRDM)
attr(dadm,"model")()$log_likelihood(p_vector,dadm) # [1] 2684.95
designRDEX <- make_design(Flist=list(v ~ lM, B ~ 1, A ~ 1, t0 ~ 1, s~1,
muS~1,sigmaS~1,tauS~1,gf~1,tf~1),
Ffactors=list(subjects=1,S=c("left","right")),Rlevels=c("stop","left","right"),
matchfun=function(d)as.character(d$S)==as.character(d$lR),
Clist=list(lM=matrix(c(-1/2,1/2),ncol=1),S=contr.helmert),
Fcovariates="SSD",constants = c(s=log(1)),model=SSrdexB)
p_vector <- sampled_p_vector(designRDEX,SSrdexB)
p_vector[1:2] <- log(c(4,1.25)) # Intercept and (multiplicative) quality
p_vector[3:4] <- c(log(1),log(0.1)) # B and A
p_vector[5] <- log(c(0.3))   # log scale t0
p_vector[6:8] <- log(c(.2,.05,.1)) # log scale mu,sigma,tau
p_vector[9:10] <- c(qnorm(0),qnorm(0))
p_vector[9:10] <- c(qnorm(.05),qnorm(0))
p_vector[9:10] <- c(qnorm(0),qnorm(.1))
p_vector[9:10] <- c(qnorm(.05),qnorm(.1))
print(load("../dataRDEX.RData"))
# Check C speedup
dadm <- design_model(dataRDEX,designRDEX)
attr(dadm,"model")()$log_likelihood(p_vector,dadm)
designLBA <- make_design(
Ffactors=list(subjects=1,S=c("left","right")),
Rlevels=c("left","right"),matchfun=function(d)d$S==d$lR,
Clist=list(lM=matrix(c(-1/2,1/2),ncol=1),S=contr.helmert),
Flist=list(v~lM,B~1,A~1,t0~1,sv~1),constants=c(sv=0),
model=lbaB)
p_vector <- sampled_p_vector(design=designLBA,model=lbaB)
p_vector[1:5] <- c(2.5,1,log(c(2,.1,.3)))
print(load("../dataLBA.RData"))
plot_defective_density(dataLBA,layout=c(1,2),factors="S")
# Check get same C and R value
dadm <- design_model(dataLBA,designLBA)
attr(dadm,"model")()$log_likelihood(p_vector,dadm)
?install
?load_all
# Be in EMC2 directory to load package as follows
devtools::load_all()
designEXG <- make_design(Flist=list(mu ~ lM, sigma ~ 1, tau ~ 1, muS~1, sigmaS~1, tauS~1, gf~ 1, tf~1),
Ffactors=list(subjects=1,S=c("left","right")),Rlevels=c("stop","left","right"),
matchfun=function(d)as.character(d$S)==as.character(d$lR),
Clist=list(lM=matrix(c(-1/2,1/2),ncol=1),S=contr.helmert),
Fcovariates="SSD",model=SSexGaussian)
p_vector <- sampled_p_vector(design=designEXG,model=SSexGaussian)
p_vector[1:2] <- log(c(.6,.75)) # Intercept and (multiplicative) quality
p_vector[3:4] <- c(log(.05),log(0.1)) # sigma and tau
p_vector[5:7] <- c(log(.2),log(.05),log(0.1)) # muS, sigmaS and tauS
p_vector[8:9] <- c(qnorm(0),qnorm(0))
p_vector[8:9] <- c(qnorm(.05),qnorm(0))
p_vector[8:9] <- c(qnorm(0),qnorm(.1))
p_vector[8:9] <- c(qnorm(.05),qnorm(.1))
# Load precomptued data ...
print(load("../dataEXG.RData"))
# Check get same C and R value
dadm <- design_model(dataEXG,designEXG)
attr(dadm,"model")()$log_likelihood(p_vector,dadm) # [1] 295.9831
devtools::install(".")
library(EMC2)
designEXG <- make_design(Flist=list(mu ~ lM, sigma ~ 1, tau ~ 1, muS~1, sigmaS~1, tauS~1, gf~ 1, tf~1),
Ffactors=list(subjects=1,S=c("left","right")),Rlevels=c("stop","left","right"),
matchfun=function(d)as.character(d$S)==as.character(d$lR),
Clist=list(lM=matrix(c(-1/2,1/2),ncol=1),S=contr.helmert),
Fcovariates="SSD",model=SSexGaussian)
# NB: Stop *must* be first level of Rlevels
designEXG <- make_design(Flist=list(mu ~ lM, sigma ~ 1, tau ~ 1, muS~1, sigmaS~1, tauS~1, gf~ 1, tf~1),
Ffactors=list(subjects=1,S=c("left","right")),Rlevels=c("stop","left","right"),
matchfun=function(d)as.character(d$S)==as.character(d$lR),
Clist=list(lM=matrix(c(-1/2,1/2),ncol=1),S=contr.helmert),
Fcovariates="SSD",model="SSexGaussian")
# NB: Stop *must* be first level of Rlevels
designEXG <- make_design(Flist=list(mu ~ lM, sigma ~ 1, tau ~ 1, muS~1, sigmaS~1, tauS~1, gf~ 1, tf~1),
Ffactors=list(subjects=1,S=c("left","right")),Rlevels=c("stop","left","right"),
matchfun=function(d)as.character(d$S)==as.character(d$lR),
Clist=list(lM=matrix(c(-1/2,1/2),ncol=1),S=contr.helmert),
Fcovariates="SSD",model=SSexGaussian())
# Emulate loading the package load package as follows, run check first if you want.
# devtools::check()
devtools::load_all()
designEXG <- make_design(Flist=list(mu ~ lM, sigma ~ 1, tau ~ 1, muS~1, sigmaS~1, tauS~1, gf~ 1, tf~1),
Ffactors=list(subjects=1,S=c("left","right")),Rlevels=c("stop","left","right"),
matchfun=function(d)as.character(d$S)==as.character(d$lR),
Clist=list(lM=matrix(c(-1/2,1/2),ncol=1),S=contr.helmert),
Fcovariates="SSD",model=SSexGaussian)
rm(list=ls())
library(EMC2)
designEXG <- make_design(Flist=list(mu ~ lM, sigma ~ 1, tau ~ 1, muS~1, sigmaS~1, tauS~1, gf~ 1, tf~1),
Ffactors=list(subjects=1,S=c("left","right")),Rlevels=c("stop","left","right"),
matchfun=function(d)as.character(d$S)==as.character(d$lR),
Clist=list(lM=matrix(c(-1/2,1/2),ncol=1),S=contr.helmert),
Fcovariates="SSD",model=SSexGaussian)
rm(list=ls())
# or to make the package properly
devtools::install(".")
library(EMC2)
designEXG <- make_design(Flist=list(mu ~ lM, sigma ~ 1, tau ~ 1, muS~1, sigmaS~1, tauS~1, gf~ 1, tf~1),
Ffactors=list(subjects=1,S=c("left","right")),Rlevels=c("stop","left","right"),
matchfun=function(d)as.character(d$S)==as.character(d$lR),
Clist=list(lM=matrix(c(-1/2,1/2),ncol=1),S=contr.helmert),
Fcovariates="SSD",model=SSexGaussian)
rm(list=ls())
library(EMC2)
designEXG <- make_design(Flist=list(mu ~ lM, sigma ~ 1, tau ~ 1, muS~1, sigmaS~1, tauS~1, gf~ 1, tf~1),
Ffactors=list(subjects=1,S=c("left","right")),Rlevels=c("stop","left","right"),
matchfun=function(d)as.character(d$S)==as.character(d$lR),
Clist=list(lM=matrix(c(-1/2,1/2),ncol=1),S=contr.helmert),
Fcovariates="SSD",model=SSexGaussian)
SSexGaussian
getAnywhere("SSexGaussian")
designEXG <- make_design(Flist=list(mu ~ lM, sigma ~ 1, tau ~ 1, muS~1, sigmaS~1, tauS~1, gf~ 1, tf~1),
Ffactors=list(subjects=1,S=c("left","right")),Rlevels=c("stop","left","right"),
matchfun=function(d)as.character(d$S)==as.character(d$lR),
Clist=list(lM=matrix(c(-1/2,1/2),ncol=1),S=contr.helmert),
Fcovariates="SSD",model=EMC2::SSexGaussian)
# Emulate loading the package load package as follows, run check first if you want.
# devtools::check()
devtools::load_all()
SSexGaussian
setwd("/Volumes/Data/Projects/EMCpackage/EMC2fork")
