Vmat <- matrix(c(-1,1),ncol=1,dimnames=list(NULL,""))
Vmat
design_a <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),
Clist=list(S=Vmat,E=Emat),
Flist=list(v~S,a~E,sv~1, t0~1, st0~1, s~1, Z~1, SZ~1, DP~1),
constants=c(s=log(1),st0=log(0),DP=qnorm(0.5),SZ=qnorm(0),sv=log(0)),
model=ddmTZD)
samplers <- make_samplers(dat, design_a)
microbenchmark::microbenchmark(
run_samplers(samplers, stage = "preburn", iter = 10, useC = T),
run_samplers(samplers, stage = "preburn", iter = 10), n_times = 10
)
samplers <- run_samplers(samplers, stage = "preburn", iter = 10, useC = T)
samplers <- run_samplers(samplers, stage = "preburn", iter = 10, useC = F)
microbenchmark::microbenchmark(
run_samplers(samplers, stage = "preburn", iter = 10, useC = T),
run_samplers(samplers, stage = "preburn", iter = 10), n_times = 10
)
run_samplers(samplers, stage = "preburn", iter = 10, useC = T),
run_samplers(samplers, stage = "preburn", iter = 10, useC = T)
t1 <- run_samplers(samplers, stage = "preburn", iter = 10, useC = T),
t1 <- run_samplers(samplers, stage = "preburn", iter = 10, useC = T)
t1 <- run_samplers(samplers, stage = "preburn", iter = 10, useC = F)
library(devtools)
load_all()
print(load("test_files/PNAS.RData"))
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
Vmat <- matrix(c(-1,1),ncol=1,dimnames=list(NULL,""))
Vmat
design_a <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),
Clist=list(S=Vmat,E=Emat),
Flist=list(v~S,a~E,sv~1, t0~1, st0~1, s~1, Z~1, SZ~1, DP~1),
constants=c(s=log(1),st0=log(0),DP=qnorm(0.5),SZ=qnorm(0),sv=log(0)),
model=ddmTZD)
dat2 <- dat[which(dat$subjects %in% (unique(dat$subjects)[1:3])),]
dat2 <- droplevels(dat2)
samplers <- make_samplers(dat2, design_a)
samplers <- run_samplers(samplers, stage = "preburn", iter = 50, useC = T, cores_for_chains = 1)
microbenchmark::microbenchmark(
run_samplers(samplers, stage = "preburn", iter = 10, useC = T),
run_samplers(samplers, stage = "preburn", iter = 10), n_times = 10
)
run_emc(samplers, verbose = T, cores_for_chains = 1, useC = T, particles = 2)
samplers <- run_samplers(samplers, stage = "preburn", iter = 50, useC = T, cores_for_chains = 1)
samplers <- run_samplers(samplers, stage = "preburn", iter = 150, useC = T, cores_for_chains = 1)
samplers_init <- make_samplers(dat2, design_a)
microbenchmark::microbenchmark(
run_samplers(samplers_init, stage = "preburn", iter = 10, useC = T),
run_samplers(samplers_init, stage = "preburn", iter = 10), n_times = 10
)
library(devtools)
load_all()
print(load("test_files/PNAS.RData"))
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
Vmat <- matrix(c(-1,1),ncol=1,dimnames=list(NULL,""))
Vmat
design_a <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),
Clist=list(S=Vmat,E=Emat),
Flist=list(v~S,a~E,sv~1, t0~1, st0~1, s~1, Z~1, SZ~1, DP~1),
constants=c(s=log(1),st0=log(0),DP=qnorm(0.5),SZ=qnorm(0),sv=log(0)),
model=ddmTZD)
dat2 <- dat[which(dat$subjects %in% (unique(dat$subjects)[1:3])),]
dat2 <- droplevels(dat2)
samplers_init <- make_samplers(dat2, design_a)
samplers <- run_samplers(samplers, stage = "preburn", iter = 100, useC = T, cores_for_chains = 1)
samplers
samplers[[1]]$samples$subj_ll
samplers <- run_samplers(samplers_init, stage = "preburn", iter = 100, useC = T, cores_for_chains = 1)
plot_chains(samplers, stage = "preburn")
plot_chains(samplers, filter = "preburn")
rm(list = ls())
library(devtools)
# Rcpp only works as fast with install like this unfortunately, if this throws errors, restarting Rstudio worked for me
# devtools::install("~/Documents/UVA/2022/EMC2")
# load_all()
library(EMC2)
load("test_files/PNAS.RData")
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
# Average rate = intercept, and rate d = difference (match-mismatch) contrast
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
design_RDM <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Clist=list(lM=ADmat,lR=ADmat,S=ADmat,E=Emat),
Flist=list(v~lM,s~1,B~E,A~1,t0~1),
constants=c(s=log(1)),
model=rdmB)
# Test single subject
dat_single <- dat[which(dat$subjects %in% (unique(dat$subjects)[1:10])),]
dat_single <- droplevels(dat_single)
# first speed test:
samplers <- make_samplers(dat_single, design_RDM)
# first let's run init separately
samplers <- run_emc(samplers, cores_per_chain =5, cores_for_chains = 3, useC = T, verbose = T)
?microbenchark::microbenchark
?microbenchmark::microbenchmark
t1 <- rmvnorm(10, 1:5, diag(5))
t1 <- mvtnorm::rmvnorm(10, 1:5, diag(5))
t1
obj <- cov(t1)
mean(abs(rowSums(obj/max(obj))) - abs(colSums(obj/max(obj)))) < .1
abs(rowSums(obj/max(obj))) - abs(colSums(obj/max(obj)))
library(rtdists)
t0 <- .2 # non decision time range between 0 and .5
v_correct <- 1.5 # drift rate correct range between 0 and
v_error <- 1 # drift rate error range between 0 and 2
B <- 1.5 # Threshold range between 1 and 2
A <- .5 # Between trial variability in start point range between 0 and 1
s <- 1 # Between trial variability in drift rate, this one we'll fix.
?rLBA
library(rtdists)
t0 <- .2 # non decision time range between 0 and .5
v_correct <- 1.5 # drift rate correct range between 0 and
v_error <- 1 # drift rate error range between 0 and 2
B <- 1 # Threshold range between .3 and 1.5
A <- .5 # Between trial variability in start point range between 0 and 1
s <- 1 # Between trial variability in drift rate, this one we'll fix.
b <- B + A
n_trials <- 100
data <- rLBA(n_trials, A = A, b = b, t0 = t0, mean_v = c(v_correct, v_error),
sd_v = c(s, s))
data
hist(data$rt)
library(rtdists)
t0 <- .2 # non decision time range between 0 and .5
v_correct <- 1.5 # drift rate correct range between 0 and
v_error <- 1 # drift rate error range between 0 and 2
B <- 1 # Threshold range between .3 and 1.5
A <- .5 # Between trial variability in start point range between 0 and 1
s <- 1 # Between trial variability in drift rate, this one we'll fix.
b <- B + A
n_trials <- 100
data <- rLBA(n_trials, A = A, b = b, t0 = t0, mean_v = c(v_correct, v_error),
sd_v = c(s, s))
hist(data$rt[data$rt < 2.5])
table(data$response)
dLBA(rt = data$rt, response = data$response, A = A, b = b, t0 = t0, mean_v = c(v_correct, v_error),
sd_v = c(s, s))
sum(log(dLBA(rt = data$rt, response = data$response, A = A, b = b, t0 = t0, mean_v = c(v_correct, v_error),
sd_v = c(s, s)))
sum(log(dLBA(rt = data$rt, response = data$response, A = A, b = b, t0 = t0, mean_v = c(v_correct, v_error),
sum(log(dLBA(rt = data$rt, response = data$response, A = A, b = b, t0 = t0, mean_v = c(v_correct, v_error),
sd_v = c(s, s))))
sum(log(dLBA(rt = data$rt, response = data$response, A = A, b = 1, t0 = t0, mean_v = c(v_correct, v_error),
sd_v = c(s, s))))
Q <- abs(rnorm(n_trials))
Q
Q <- abs(rnorm(n_trials))
v_intercept <- .5
v_RL <- v_intercept + Beta * Q
Q <- abs(rnorm(n_trials))
v_intercept <- .5
Beta <- .4
v_RL <- v_intercept + Beta * Q
v_std <- rep(1, n_trials)
v_std
v_RL
rm(list=ls())
# devtools::install()
library(EMC2)
print(load("test_files/PNAS.RData"))
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
head(dat)
# NB: This data has been truncated at 0.25s and 1.5s
# Average rate = intercept, and rate d = difference (match-mismatch) contrast
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
# Here we fit a series of models
# We'll first build several plausible models and then do model selection
# Only B affected by E
design_B <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Clist=list(lM=ADmat,lR=ADmat,S=ADmat,E=Emat),
Flist=list(v~lM,sv~1,B~E,A~1,t0~1),
constants=c(sv=log(1)),
model=lbaB)
samplers <- make_samplers(dat, design_B, nuisance = c(6,7))
devtools::load_all()
samplers <- make_samplers(dat, design_B, nuisance = c(6,7))
samplers <- run_emc(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 250)
debug(run_stage)
samplers <- run_emc(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 250)
rm(list=ls())
# devtools::install()
library(EMC2)
print(load("test_files/PNAS.RData"))
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
head(dat)
# NB: This data has been truncated at 0.25s and 1.5s
# Average rate = intercept, and rate d = difference (match-mismatch) contrast
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
# Here we fit a series of models
# We'll first build several plausible models and then do model selection
# Only B affected by E
design_B <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Clist=list(lM=ADmat,lR=ADmat,S=ADmat,E=Emat),
Flist=list(v~lM,sv~1,B~E,A~1,t0~1),
constants=c(sv=log(1)),
model=lbaB)
devtools::load_all()
samplers <- make_samplers(dat, design_B, nuisance = c(6,7))
samplers <- run_emc(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 250)
debug(run_stage)
samplers <- run_emc(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 250)
get_variant_funs("diagonal")$gibbs_step(pmwgs$samples_nuis, pmwgs$samples$alpha[nuisance,,j-1])
debug(get_variant_funs("diagonal")$gibbs_step)
sampler$n_pars
last$tvinv
prior$theta_mu_invar
alpha
devtools::load_all()
samplers <- make_samplers(dat, design_B, nuisance = c(6,7))
devtools::load_all()
samplers <- make_samplers(dat, design_B, nuisance = c(6,7))
debug(run_stage)
samplers <- run_emc(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 250)
pmwgs$samples_nuis
devtools::load_all()
samplers <- make_samplers(dat, design_B, nuisance = c(6,7))
devtools::load_all()
samplers <- make_samplers(dat, design_B, nuisance = c(6,7))
samplers <- run_emc(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 250)
debug(run_stage)
samplers <- run_emc(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 250)
debug(get_variant_funs("diagonal")$gibbs_step)
get_variant_funs("diagonal")$gibbs_step(pmwgs$sampler_nuis, pmwgs$samples$alpha[nuisance,,j-1])
last$tvinv
sampler$n_subjects
prior$theta_mu_invar
hyper$v_half
rgamma(n=sampler$n_pars, shape=hyper$v_half/2 + sampler$n_subjects/2, rate=hyper$v_half/last$a_half +
rowSums( (alpha-tmu)^2 ) / 2)
last$a_half
last$tmu
last$tvinv
debug(init)
samplers <- run_emc(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 250)
startpoints_nuis
debug(get_variant_funs("diagonal")$fill_samples)
group_level$a_half
samples
pmwgs$samples
samples
extend_sampler
pmwgs$sampler_nuis
devtools::load_all()
samplers <- make_samplers(dat, design_B, nuisance = c(6,7))
samplers <- run_emc(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 250)
debug(run_stage)
samplers <- run_emc(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 250)
pmwgs$sampler_nuis
get_variant_funs("diagonal")$gibbs_step(pmwgs$sampler_nuis, pmwgs$samples$alpha[nuisance,,j-1])
debug(get_variant_funs("diagonal")$gibbs_step)
get_variant_funs("diagonal")$gibbs_step(pmwgs$sampler_nuis, pmwgs$samples$alpha[nuisance,,j-1])
last
sampler$samples
debug(last_sample_standard)
last_sample_standard(sampler$samples)
devtools::load_all()
samplers <- make_samplers(dat, design_B, nuisance = c(6,7))
devtools::load_all()
samplers <- make_samplers(dat, design_B, nuisance = c(6,7))
debug(run_stage)
samplers <- run_emc(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 250)
get_variant_funs("diagonal")$gibbs_step(pmwgs$sampler_nuis, pmwgs$samples$alpha[nuisance,,j-1])
mclapply(X=1:pmwgs$n_subjects,FUN = new_particle, data, particles, pars, eff_mu,
eff_var, mix, pmwgs$ll_func, epsilon, subjects, components,
prev_ll = pmwgs$samples$subj_ll[,j-1], stage, chains_cov,
variant_funs, block_idx, shared_ll_idx, mc.cores =n_cores)
pars$tmu
pars$tvar
debug(new_particle)
mclapply(X=1:pmwgs$n_subjects,FUN = new_particle, data, particles, pars, eff_mu,
eff_var, mix, pmwgs$ll_func, epsilon, subjects, components,
prev_ll = pmwgs$samples$subj_ll[,j-1], stage, chains_cov,
variant_funs, block_idx, shared_ll_idx, mc.cores =1)
proposals
mclapply(X=1:pmwgs$n_subjects,FUN = new_particle, data, particles, pars, eff_mu,
eff_var, mix, pmwgs$ll_func, epsilon, subjects, components,
prev_ll = pmwgs$samples$subj_ll[,j-1], stage, chains_cov,
variant_funs, block_idx, shared_ll_idx, mc.cores =n_cores)
mclapply(X=1:pmwgs$n_subjects,FUN = new_particle, data, particles, pars, eff_mu,
eff_var, mix, pmwgs$ll_func, epsilon, subjects, components,
prev_ll = pmwgs$samples$subj_ll[,j-1], stage, chains_cov,
variant_funs, block_idx, shared_ll_idx, mc.cores =1)
idx
pop_particles
ind_particles
subj_mu
var_subj
devtools::load_all()
samplers <- make_samplers(dat, design_B, nuisance = c(6,7))
debug(run_stage)
samplers <- run_emc(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 250)
devtools::load_all()
samplers <- make_samplers(dat, design_B, nuisance = c(6,7))
debug(run_stage)
samplers <- run_emc(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 250)
c(T, T, T, F, T)[F,T,F,T,F]
test <- c(T, T, T, F, T)
test
test[c(T,F,T,F,T)]
asjklas[1,1,1]
devtools::load_all()
samplers <- make_samplers(dat, design_B, nuisance = c(6,7))
debug(run_stage)
samplers <- auto_burn(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T)
undebug(run_stage)
samplers <- auto_burn(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T)
debug(create_eff_proposals)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T)
devtools::load_all()
debug(create_eff_proposals)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T)
debug(extract_samples)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T)
devtools::load_all()
debug(extract_samples)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T)
debug(create_eff_proposals)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T)
devtools::load_all()
debug(create_eff_proposals)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T)
debug(test_adapted)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T)
devtools::load_all()
debug(test_adapted)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T)
debug(run_stage)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T)
pmwgs$sampler_nuis
get_variant_funs("diagonal")$gibbs_step(pmwgs$sampler_nuis, pmwgs$samples$alpha[nuisance,,j-1])
debug(get_variant_funs("diagonal")$gibbs_step)
get_variant_funs("diagonal")$gibbs_step(pmwgs$sampler_nuis, pmwgs$samples$alpha[nuisance,,j-1])
last
sampler$samples
devtools::load_all()
debug(run_stage)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T)
devtools::load_all()
debug(run_stage)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T)
get_variant_funs("diagonal")$gibbs_step(pmwgs$sampler_nuis, pmwgs$samples$alpha[nuisance,,j-1])
pmwgs$sampler_nuis$samples$idx
pmwgs$samples$idx
devtools::load_all()
debug(run_stage)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T)
devtools::load_all()
debug(test_adapted)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, min_unique = 50, step_size = 50)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, min_unique = 50, step_size = 50)
idx <- comp == components
n_cores_conditional = 1
for(comp in unique(components)){
idx <- comp == components
nuis_idx <- nuisance[idx]
if(any(nuis_idx)){
parallel::mclapply(X = 1:n_subjects,
FUN = variant_funs$get_conditionals,samples = test_samples,
n_pars = sum(idx[!nuisance]), iteration =  iteration, idx = idx[!nuis_idx],
mc.cores = n_cores)
}
parallel::mclapply(X = 1:sampler$n_subjects,FUN = variant_funs$get_conditionals,samples = test_samples,
n_pars = sum(idx[!nuis_idx]), idx = idx[nuis_idx], mc.cores = n_cores_conditional)
}
comp
idx
idx <- comp == components
nuis_idx <- nuisance[idx]
nuis_idx
parallel::mclapply(X = 1:n_subjects,
FUN = variant_funs$get_conditionals,samples = test_samples,
n_pars = sum(idx[!nuisance]), iteration =  iteration, idx = idx[!nuis_idx],
mc.cores = n_cores)
parallel::mclapply(X = 1:n_subjects,
FUN = variant_funs$get_conditionals,samples = test_samples,
n_pars = sum(idx[!nuisance]), iteration =  iteration, idx = idx[!nuis_idx],
mc.cores = 1)
parallel::mclapply(X = 1:sampler$n_subjects,
FUN = variant_funs$get_conditionals,samples = test_samples,
n_pars = sum(idx[!nuisance]), iteration =  iteration, idx = idx[!nuis_idx],
mc.cores = 1)
parallel::mclapply(X = 1:sampler$n_subjects,
FUN = variant_funs$get_conditionals,samples = test_samples$nuisance,
n_pars = sum(idx[!nuisance]), iteration =  iteration, idx = idx[!nuis_idx],
mc.cores = 1)
parallel::mclapply(X = 1:sampler$n_subjects,
FUN = variant_funs$get_conditionals,samples = test_samples$nuisance,
n_pars = sum(idx[!nuisance]), idx = idx[!nuis_idx],
mc.cores = 1)
test_samples$nuisance
debug(extract_samples)
devtools::load_all()
debug(extract_samples)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, min_unique = 40, step_size = 25)
get_variant_funs("diagonal")$filtered_samples(sampler$sampler_nuis, full_filter)
debug(get_variant_funs("diagonal")$filtered_samples)
get_variant_funs("diagonal")$filtered_samples(sampler$sampler_nuis, full_filter)
filter
debug(extract_samples)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, min_unique = 40, step_size = 25)
full_filter
get_variant_funs("diagonal")$filtered_samples(sampler$sampler_nuis, full_filter)
filter
sampler$sampler_nuis$samples
get_variant_funs("diagonal")$filtered_samples(sampler$sampler_nuis, full_filter)
out <- list(
theta_mu = sampler$samples$theta_mu[, filter],
theta_var = sampler$samples$theta_var[, , filter],
alpha = sampler$samples$alpha[, , filter],
iteration = length(filter)
)
out
sampler$samples$theta_mu
sampler$samples
devtools::load_all()
debug(extract_samples)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, min_unique = 40, step_size = 25)
sampler$sampler_nuis$samples
sampler$samples
samples <- merge_samples(samplers)
samples$sampler_nuis$samples
debug(merge_samples)
samples <- merge_samples(samplers)
sampled_objects
devtools::load_all()
samples <- merge_samples(samplers)
samples$sampler_nuis$samples
devtools::load_all()
debug(test_adapted)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, min_unique = 40, step_size = 25)
comp <- 1
idx <- comp == components
nuis_idx <- nuisance[idx]
parallel::mclapply(X = 1:sampler$n_subjects,
FUN = variant_funs$get_conditionals,samples = test_samples$nuisance,
n_pars = sum(idx[nuisance]), idx = idx[nuis_idx],
mc.cores = 1)
parallel::mclapply(X = 1:sampler$n_subjects,FUN = variant_funs$get_conditionals,samples = test_samples,
n_pars = sum(idx[!nuis_idx]), idx = idx[nuis_idx], mc.cores = n_cores_conditional)
test_samples$nuisance
devtools::load_all()
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, min_unique = 40, step_size = 25)
devtools::load_all()
debug(test_adapted)
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, min_unique = 40, step_size = 25)
n_cores
comp <- 1
idx <- comp == components
nuis_idx <- nuisance[idx]
parallel::mclapply(X = 1:sampler$n_subjects,
FUN = get_variant_funs("diagonal")$get_conditionals,samples = test_samples$nuisance,
n_pars = sum(idx[nuisance]), idx = idx[nuis_idx],
mc.cores = 1)
parallel::mclapply(X = 1:sampler$n_subjects,FUN = variant_funs$get_conditionals,samples = test_samples,
n_pars = sum(idx[!nuis_idx]), idx = idx[nuis_idx], mc.cores = n_cores_conditional)
devtools::load_all()
samplers <- run_adapt(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, min_unique = 40, step_size = 50)
samplers <- run_sample(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 200)
debug(create_eff_proposals)
samplers <- run_sample(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 200)
conditionals[,1]
conditionals[,1,]
conditionals
devtools::load_all()
debug(create_eff_proposals)
samplers <- run_sample(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 200)
devtools::load_all()
debug(create_eff_proposals)
samplers <- run_sample(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 200)
eff_mu
eff_var
devtools::load_all()
samplers <- run_sample(samplers, cores_per_chain = 8, cores_for_chains = 1, verbose = T, iter = 200)
