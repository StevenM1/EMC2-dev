print(emc)
attr(emc[[1]], "variant_funs") <- get_variant_funs("SEM")
attr(emc[[2]], "variant_funs") <- get_variant_funs("SEM")
attr(emc[[3]], "variant_funs") <- get_variant_funs("SEM")
withK <- emc
chain_n(withG)
chain_n(withK)
compare(list(G = withG, K = withK), BayesFactor = F)
compare(list(G = withG), BayesFactor = F)
.rs.restartR()
devtools::load_all()
compare(list(G = withG), BayesFactor = F)
debug(group_IC_SEM)
compare(list(G = withG), BayesFactor = F)
debug(IC)
compare(list(G = withG), BayesFactor = F)
debug(attr(emc[[1]], "variant_funs")$group_IC)
attr(emc[[1]], "variant_funs")$group_IC(emc, stage=stage,filter=filter)
attr(emc, "variant_funs")$type
attr(emc[[1]], "variant_funs")
attr(emc[[1]], "variant_funs")$type
get_pars(emc, selection = "alpha", stage = stage, filter = filter,
return_mcmc = FALSE, merge_chains = TRUE)
debug(get_objects)
get_pars(emc, selection = "alpha", stage = stage, filter = filter,
return_mcmc = FALSE, merge_chains = TRUE)
type
devtools::load_all()
load("/home/niek/Downloads/SEM_LNR_with_K_large.RData")
16/40
1/10
plot(emc, selection = "factor_regressors")
plot(emc, selection = "regressors")
debug(plot.emc)
plot(emc, selection = "factor_regressors")
debug(plot_mcmc_list)
length(MCMC_samples[[1]])
MCMC_samples
debug(get_pars)
plot(emc, selection = "factor_regressors")
samples
load("~/Downloads/SEM_LNR_with_G_large.RData")
emc <- subset(emc, length.out = 1000)
attr(emc[[1]], "variant_funs") <- get_variant_funs("SEM")
attr(emc[[2]], "variant_funs") <- get_variant_funs("SEM")
attr(emc[[3]], "variant_funs") <- get_variant_funs("SEM")
devtools::load_all()
plot(emc, selection = "factor_regressors")
debug(plot_mcmc_list)
plot(emc, selection = "factor_regressors")
debug(plot_mcmc_list)
plot(emc, selection = "factor_regressors")
length(MCMC_samples)
names(MCMC_samples)[i]
paste0(selection, ": ", names(MCMC_samples)[i])
ifelse(length(MCMC_samples) == 1, names(MCMC_samples)[i], paste0(selection, ": ", names(MCMC_samples)[i]))
x_name <- NULL
cur_dots <- add_defaults(cur_dots, xlab = x_name)
cur_dots
do.call(fun, c(list(MCMC_samples[[i]]), fix_dots_plot(cur_dots),
fix_dots(cur_dots, get(fun), consider_dots = F, exclude =
c(names(par()), names(formals(arrows)), names(formals(plot.default))))))
emc[[1]]$samples$G |> dimnames()
devtools::load_all()
devtools::load_all()
compare(list(G = emc), BayesFactor = F, group_only = F)
devtools::load_all()
compare(list(G = emc), BayesFactor = F, group_only = F)
undebug(get_pars)
.rs.restartR()
devtools::load_all()
compare(list(G = emc), BayesFactor = F, group_only = T)
load("~/Downloads/SEM_LNR_with_K_large.RData")
devtools::load_all()
compare(list(G = emc), BayesFactor = F, group_only = T)
get_objects
devtools::load_all()
debug(get_objects)
compare(list(G = emc), BayesFactor = F, group_only = T)
type
type
run_bridge_sampling(list(samples_LNR), cores_per_prop = 2)
library(EMC2)
MLL <- run_bridge_sampling(list(samples_LNR), cores_per_prop = 2)
MLL <- run_bridge_sampling(samples_LNR, cores_per_prop = 2)
run_bridge_sampling(samples_LNR, cores_per_prop = 2, both_splits = FALSE)
MLL
design_in <- design(data = forstmann,model=DDM,
formula =list(v~0+S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
constants=c(s=log(1)))
# Then make the emc, we've omitted a prior here for brevity so default priors will be used.
emc <- make_emc(forstmann, design_in)
# Now for example we can specify that we only want to run the "preburn" phase
# for MCMC 200 iterations
emc <- run_emc(emc, stage = "preburn", stop_criteria = list(iter = 10))
design_in <- design(data = forstmann,model=DDM,
formula =list(v~0+S,a~E, t0~1, s~1),
constants=c(s=log(1)))
# Then make the emc, we've omitted a prior here for brevity so default priors will be used.
emc <- make_emc(forstmann, design_in, compress = FALSE)
# Now for example we can specify that we only want to run the "preburn" phase
# for MCMC 200 iterations
emc <- run_emc(emc, stage = "preburn", stop_criteria = list(iter = 10))
credible(samples_LNR, x_name = "m")
compare(list(samples_LNR))
M1 <- M0 <- run_bridge_sampling(samples_LNR, both_splits = FALSE, cores_for_props = 2)
get_BayesFactor(M1, M0)
compare_subject(samples_LNR)
compare_subject(list(m0 = samples_LNR, m1 = samples_LNR))
design_DDMaE <- design(data = forstmann,model=DDM,
formula =list(v~0+S,a~E, t0~1, s~1, Z~1),
constants=c(s=log(1)))
DDMaE <- make_emc(forstmann, design_DDMaE)
# set up our mean starting points (same used across subjects).
mu <- c(v_Sleft=-2,v_Sright=2,a=log(1),a_Eneutral=log(1.5),a_Eaccuracy=log(2),
t0=log(.2),Z=qnorm(.5),sv=log(.5))
# Small variances to simulate start points from a tight range
var <- diag(0.05, length(mu))
# Initialize chains, 4 cores per chain, and parallelizing across our 3 chains as well
# so 4*3 cores used.
DDMaE <- init_chains(DDMaE, start_mu = p_vector, start_var = var, cores_per_chain = 4)
# Initialize chains, 4 cores per chain, and parallelizing across our 3 chains as well
# so 4*3 cores used.
DDMaE <- init_chains(DDMaE, start_mu = p_vector, start_var = var, cores_per_chain = 1)
# Initialize chains, 4 cores per chain, and parallelizing across our 3 chains as well
# so 4*3 cores used.
DDMaE <- init_chains(DDMaE, start_mu = p_vector, start_var = var, cores_per_chain = 1, cores_for_chains = 1)
# Initialize chains, 4 cores per chain, and parallelizing across our 3 chains as well
# so 4*3 cores used.
debug(init_chains)
DDMaE <- init_chains(DDMaE, start_mu = p_vector, start_var = var, cores_per_chain = 1, cores_for_chains = 1)
debug(init)
DDMaE <- init_chains(DDMaE, start_mu = p_vector, start_var = var, cores_per_chain = 1, cores_for_chains = 1)
variant_funs
design_DDMaE <- design(data = forstmann,model=DDM,
formula =list(v~0+S,a~E, t0~1, s~1, Z~1),
constants=c(s=log(1)))
DDMaE <- make_emc(forstmann, design_DDMaE)
# set up our mean starting points (same used across subjects).
mu <- c(v_Sleft=-2,v_Sright=2,a=log(1),a_Eneutral=log(1.5),a_Eaccuracy=log(2),
t0=log(.2),Z=qnorm(.5),sv=log(.5))
# Small variances to simulate start points from a tight range
var <- diag(0.05, length(mu))
attr(DDMaE[[1]], "variant_funs")
# Initialize chains, 4 cores per chain, and parallelizing across our 3 chains as well
# so 4*3 cores used.
debug(init_chains)
DDMaE <- init_chains(DDMaE, start_mu = p_vector, start_var = var, cores_per_chain = 1, cores_for_chains = 1)
emc[[1]]
debug(init)
pmwgs
variant_funs$get_startpoints()
variant_funs$get_startpoints(pmwgs,
start_mu, start_var)
design_DDMaE <- design(data = forstmann,model=DDM,
formula =list(v~0+S,a~E, t0~1, s~1, Z~1),
constants=c(s=log(1)))
DDMaE <- make_emc(forstmann, design_DDMaE)
# set up our mean starting points (same used across subjects).
mu <- c(v_Sleft=-2,v_Sright=2,a=log(1),a_Eneutral=log(1.5),a_Eaccuracy=log(2),
t0=log(.2),Z=qnorm(.5),sv=log(.5))
# Small variances to simulate start points from a tight range
var <- diag(0.05, length(mu))
# Initialize chains, 4 cores per chain, and parallelizing across our 3 chains as well
# so 4*3 cores used.
DDMaE <- init_chains(DDMaE, start_mu = mu, start_var = var, cores_per_chain = 4)
.rs.restartR()
design_DDMaE <- design(data = forstmann,model=DDM,
formula =list(v~0+S,a~E, t0~1, s~1, Z~1),
constants=c(s=log(1)))
DDMaE <- make_emc(forstmann, design_DDMaE)
# set up our mean starting points (same used across subjects).
mu <- c(v_Sleft=-2,v_Sright=2,a=log(1),a_Eneutral=log(1.5),a_Eaccuracy=log(2),
t0=log(.2),Z=qnorm(.5),sv=log(.5))
# Small variances to simulate start points from a tight range
var <- diag(0.05, length(mu))
# Initialize chains, 4 cores per chain, and parallelizing across our 3 chains as well
# so 4*3 cores used.
DDMaE <- init_chains(DDMaE, start_mu = mu, start_var = var, cores_per_chain = 1, cores_for_chains = 1)
mu
sampled_p_vector(design_DDMaE)
design_DDMaE <- design(data = forstmann,model=DDM,
formula =list(v~0+S,a~E, t0~1, s~1, Z~1),
constants=c(s=log(1)))
DDMaE <- make_emc(forstmann, design_DDMaE)
# set up our mean starting points (same used across subjects).
mu <- c(v_Sleft=-2,v_Sright=2,a=log(1),a_Eneutral=log(1.5),a_Eaccuracy=log(2),
t0=log(.2),Z=qnorm(.5))
# Small variances to simulate start points from a tight range
var <- diag(0.05, length(mu))
# Initialize chains, 4 cores per chain, and parallelizing across our 3 chains as well
# so 4*3 cores used.
DDMaE <- init_chains(DDMaE, start_mu = mu, start_var = var, cores_per_chain = 1, cores_for_chains = 1)
design_DDMaE <- design(data = forstmann,model=DDM,
formula =list(v~0+S,a~E, t0~1, s~1, Z~1),
constants=c(s=log(1)))
DDMaE <- make_emc(forstmann, design_DDMaE)
# set up our mean starting points (same used across subjects).
mu <- c(v_Sleft=-2,v_Sright=2,a=log(1),a_Eneutral=log(1.5),a_Eaccuracy=log(2),
t0=log(.2),Z=qnorm(.5))
# Small variances to simulate start points from a tight range
var <- diag(0.05, length(mu))
# Initialize chains, 4 cores per chain, and parallelizing across our 3 chains as well
# so 4*3 cores used.
DDMaE <- init_chains(DDMaE, start_mu = mu, start_var = var, cores_per_chain = 3)
devtools::check()
devtools::check()
devtools::check()
help(package = "EMC2")
help(package = "brms")
rm(list = ls())
devtools::load_all()
# Make some standard data to be modified for model tests.
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# debug(design)
design0 <- design(
factors=list(subjects=1,S=1:2),
Rlevels = 1:2,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
contrasts=list(lM=ADmat),model=RDM)
# Make some data (actual data is irrelevant, used as a design template)
ntrials <- 50
p_vector <- sampled_p_vector(design0,doMap=FALSE)
p_vector[1:5] <- c(log(2),log(1),log(2),log(1.5),log(.3))
data <- make_data(p_vector,design0,n_trials=ntrials)
data <- data[order(runif(nrow(data))),]
data$trials[data$S==1] <- 1:ntrials
data$trials[data$S==2] <- 1:ntrials
data$strial <- data$trials/max(data$trials)
# For "polynomial" trends, we change the range to -1/2 to 1/2 so all
# shapes can be captured
data$ptrial <- data$strial-.5
dynamic1 <- list(B=list(covnames="strial",dyntype="li", dnames = "beta", shared = TRUE),
v=list(covnames="strial",dyntype="li", dnames = "beta", shared = TRUE))
dynamic <- dynamic1  # B linear increasing transform
devtools::load_all()
dynamic <- make_trend(par_names = c("B", "v"), cov_names = "strial", kernels = c("exp_incr", "poly3"))
debug(design)
ddesign <- design(data=data,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
trend=dynamic,
contrasts=list(lM=ADmat),model=RDM)
nams
transform
fill_transform(transform,model)
debug(check_pars_trend)
pt
attr(design, "p_vector")
ddesign <- design(data=data,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
trend=dynamic,
contrasts=list(lM=ADmat),model=RDM)
design$model()
debug(check_pars_trend)
pt
attr(design, "p_vector")
attr(attr(design, "p_vector")[[1]], "map")
attr(design, "p_vector")[[1]]
attr(attr(design, "p_vector"), "map")
attr(attr(design, "p_vector"), "map") |> unlist()
lapply(attr(attr(design, "p_vector"), "map"), colnames)
sapply(attr(attr(design, "p_vector"), "map"), colnames)
unlist(lapply(attr(attr(design, "p_vector"), "map"), colnames))
setNames(!logical(length(pt)), names(pt))
length(pt)
devtools::load_all()
dynamic <- make_trend(par_names = c("B", "v"), cov_names = "strial", kernels = c("exp_incr", "poly3"))
debug(check_pars_trend)
ddesign <- design(data=data,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
trend=dynamic,
contrasts=list(lM=ADmat),model=RDM)
isd
devtools::load_all()
dat <- forstmann
devtools::load_all()
dat <- forstmann
# function that takes the lR factor (named diff in the following function) and
# returns a logical defining the correct response for each stimulus. In this
# case the match is simply such that the S factor equals the latent response factor.
matchfun <- function(d)d$S==d$lR
# design an "average and difference" contrast matrix
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"diff"))
# specify design
debug(design_model)
design_LBABE <- design(data = dat,model=LBA,matchfun=matchfun,
formula=list(v~lM,sv~lM,B~E+lR,A~1,t0~1),
contrasts=list(v=list(lM=ADmat)),constants=c(sv=log(1)))
rt_check
dadm$lR
rm(list = ls())
devtools::load_all()
# Make some standard data to be modified for model tests.
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# debug(design)
design0 <- design(
factors=list(subjects=1,S=1:2),
Rlevels = 1:2,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
contrasts=list(lM=ADmat),model=RDM)
rm(list = ls())
devtools::load_all()
# Make some standard data to be modified for model tests.
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# debug(design)
design0 <- design(
factors=list(subjects=1,S=1:2),
Rlevels = 1:2,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
contrasts=list(lM=ADmat),model=RDM)
rm(list = ls())
devtools::load_all()
# Make some standard data to be modified for model tests.
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# debug(design)
design0 <- design(
factors=list(subjects=1,S=1:2),
Rlevels = 1:2,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
contrasts=list(lM=ADmat),model=RDM)
rm(list = ls())
devtools::load_all()
# Make some standard data to be modified for model tests.
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# debug(design)
design0 <- design(
factors=list(subjects=1,S=1:2),
Rlevels = 1:2,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
contrasts=list(lM=ADmat),model=RDM)
rm(list = ls())
devtools::load_all()
# Make some standard data to be modified for model tests.
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# debug(design)
design0 <- design(
factors=list(subjects=1,S=1:2),
Rlevels = 1:2,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
contrasts=list(lM=ADmat),model=RDM)
# Make some data (actual data is irrelevant, used as a design template)
ntrials <- 50
p_vector <- sampled_p_vector(design0,doMap=FALSE)
p_vector[1:5] <- c(log(2),log(1),log(2),log(1.5),log(.3))
data <- make_data(p_vector,design0,n_trials=ntrials)
data <- data[order(runif(nrow(data))),]
data$trials[data$S==1] <- 1:ntrials
data$trials[data$S==2] <- 1:ntrials
data$strial <- data$trials/max(data$trials)
# For "polynomial" trends, we change the range to -1/2 to 1/2 so all
# shapes can be captured
data$ptrial <- data$strial-.5
dynamic1 <- list(B=list(covnames="strial",dyntype="li", dnames = "beta", shared = TRUE),
v=list(covnames="strial",dyntype="li", dnames = "beta", shared = TRUE))
dynamic <- dynamic1  # B linear increasing transform
devtools::load_all()
dynamic <- make_trend(par_names = c("B", "v"), cov_names = "strial", kernels = c("exp_incr", "poly3"))
ddesign <- design(data=data,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
trend=dynamic,
contrasts=list(lM=ADmat),model=RDM)
rm(list = ls())
devtools::load_all()
# Make some standard data to be modified for model tests.
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# debug(design)
design0 <- design(
factors=list(subjects=1,S=1:2),
Rlevels = 1:2,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
contrasts=list(lM=ADmat),model=RDM)
rm(list = ls())
devtools::load_all()
# Make some standard data to be modified for model tests.
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# debug(design)
design0 <- design(
factors=list(subjects=1,S=1:2),
Rlevels = 1:2,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
contrasts=list(lM=ADmat),model=RDM)
# Make some data (actual data is irrelevant, used as a design template)
ntrials <- 50
p_vector <- sampled_p_vector(design0,doMap=FALSE)
p_vector[1:5] <- c(log(2),log(1),log(2),log(1.5),log(.3))
data <- make_data(p_vector,design0,n_trials=ntrials)
data <- data[order(runif(nrow(data))),]
data$trials[data$S==1] <- 1:ntrials
data$trials[data$S==2] <- 1:ntrials
data$strial <- data$trials/max(data$trials)
# For "polynomial" trends, we change the range to -1/2 to 1/2 so all
# shapes can be captured
data$ptrial <- data$strial-.5
dynamic1 <- list(B=list(covnames="strial",dyntype="li", dnames = "beta", shared = TRUE),
v=list(covnames="strial",dyntype="li", dnames = "beta", shared = TRUE))
dynamic <- dynamic1  # B linear increasing transform
devtools::load_all()
dynamic <- make_trend(par_names = c("B", "v"), cov_names = "strial", kernels = c("exp_incr", "poly3"))
ddesign <- design(data=data,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
trend=dynamic,
contrasts=list(lM=ADmat),model=RDM)
devtools::load_all()
dynamic <- make_trend(par_names = c("B", "v"), cov_names = "strial", kernels = c("exp_incr", "poly3"))
ddesign <- design(data=data,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
trend=dynamic,
contrasts=list(lM=ADmat),model=RDM)
debug(design_model)
ddesign <- design(data=data,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
trend=dynamic,
contrasts=list(lM=ADmat),model=RDM)
devtools::load_all()
dynamic <- make_trend(par_names = c("B", "v"), cov_names = "strial", kernels = c("exp_incr", "poly3"))
debug(design_model)
ddesign <- design(data=data,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
trend=dynamic,
contrasts=list(lM=ADmat),model=RDM)
design$trend$B
lapply(design$trend, function(x) x$trend_pnames)
sapply(design$trend, function(x) x$trend_pnames)
unlist(lapply(design$trend, function(x) x$trend_pnames))
devtools::load_all()
dynamic <- make_trend(par_names = c("B", "v"), cov_names = "strial", kernels = c("exp_incr", "poly3"))
ddesign <- design(data=data,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
trend=dynamic,
contrasts=list(lM=ADmat),model=RDM)
# Set appropriate parameter vector for different dynamic functions
p_vector <- sampled_p_vector(ddesign,doMap=FALSE)
p_vector
dynamic
trend
dynamic
devtools::load_all()
dynamic <- make_trend(par_names = c("B", "v"), cov_names = "strial", kernels = c("exp_incr", "poly3"))
debug(update_model_trend)
ddesign <- design(data=data,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
trend=dynamic,
contrasts=list(lM=ADmat),model=RDM)
kernel_transforms
base_transforms
trend
names(trend_transform)
trend_transform
base_transforms
debug(design)
ddesign <- design(data=data,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
trend=dynamic,
contrasts=list(lM=ADmat),model=RDM)
transform
model_list$transform
model_list$pre_transform
p_vector
rm(list = ls())
devtools::load_all()
# Make some standard data to be modified for model tests.
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# debug(design)
design0 <- design(
factors=list(subjects=1,S=1:2),
Rlevels = 1:2,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
contrasts=list(lM=ADmat),model=RDM)
# Make some data (actual data is irrelevant, used as a design template)
ntrials <- 50
p_vector <- sampled_p_vector(design0,doMap=FALSE)
p_vector[1:5] <- c(log(2),log(1),log(2),log(1.5),log(.3))
data <- make_data(p_vector,design0,n_trials=ntrials)
data <- data[order(runif(nrow(data))),]
data$trials[data$S==1] <- 1:ntrials
data$trials[data$S==2] <- 1:ntrials
data$strial <- data$trials/max(data$trials)
# For "polynomial" trends, we change the range to -1/2 to 1/2 so all
# shapes can be captured
data$ptrial <- data$strial-.5
dynamic1 <- list(B=list(covnames="strial",dyntype="li", dnames = "beta", shared = TRUE),
v=list(covnames="strial",dyntype="li", dnames = "beta", shared = TRUE))
dynamic <- dynamic1  # B linear increasing transform
devtools::load_all()
dynamic <- make_trend(par_names = c("B", "v"), cov_names = "strial", kernels = c("exp_incr", "poly3"))
debug(update_model_trend)
# debug(design)
ddesign <- design(data=data,
matchfun=function(d)d$S==d$lR,
formula=list(B~lR,v~lM,t0~1),
trend=dynamic,
contrasts=list(lM=ADmat),model=RDM)
