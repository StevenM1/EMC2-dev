sigma_psi <- 0.02
mu_drift_match <- 4
sigma_drift_match <- 0.35
mu_drift_mismatch <- 1
sigma_drift_mismatch <- 0.35
mu_sigma <- 0.7
sigma_sigma <- 0.15
boundary <- 1
drift_match <- numeric(I)
drift_mismatch <- numeric(I)
sigma <- numeric(I)
psi <- numeric(I)
for(i in 1:I) {
drift_match[i] <- rnorm(1, mu_drift_match, sigma_drift_match)
drift_mismatch[i] <- rnorm(1, mu_drift_mismatch, sigma_drift_mismatch)
sigma[i] <- rnorm(1, mu_sigma, sigma_sigma)
psi[i] <- rtnorm(1, mean = mu_psi, sd = sigma_psi, a = 0)
}
dat <- data.frame(I = rep(1:I, each = J),
m = rep(NA, I*J),
t = rep(NA, I*J))
for(i in 1:I){
for(j in 1:J){
Y[j,1,i] <- rwald(1, mu = boundary/drift_match[i], lambda = (boundary/sigma[i])^2)
Y[j,2,i] <- rwald(1, mu = boundary/drift_mismatch[i], lambda = (boundary/sigma[i])^2)
dat[dat$I==i,"t"][j] <- psi[i] + min(Y[j,,i])
dat[dat$I==i,"m"][j] <- which.min(Y[j,,i])
}
}
colnames(dat) <- c("subjects", "R", "rt")
dat$R <- as.factor(dat$R)
dat$subjects <- as.factor(dat$subjects)
library(devtools)
load_all()
#### Models -----
# Mu varies by stimulus, emphasis, and latent match
design_test <- make_design(
Ffactors=list(subjects=levels(dat$subjects)),
Rlevels=levels(dat$R),
Flist=list(v~R,B~1,s~1,t0~1, A ~ 1),
constants=c(B=log(1), A = log(0)),
model=rdmB)
samplers <- make_samplers(list(dat, dat), list(design_test, design_test), type = "standard", n_chains = 3)
samplers <- run_emc(samplers, verbose = T, cores_for_chains = 3, cores_per_chain = 2, useC = T)
samplers <- run_emc(samplers, verbose = T, cores_for_chains = 1, cores_per_chain = 1, useC = T)
debug(calc_ll_manager)
samplers <- run_emc(samplers, verbose = T, cores_for_chains = 1, cores_per_chain = 1, useC = T)
samplers <- run_emc(samplers, verbose = T, cores_for_chains = 1, cores_per_chain = 1, useC = T)
# Rcpp only works as fast with install like this unfortunately, if this throws errors, restarting Rstudio worked for me
# devtools::install("~/Documents/UVA/2022/EMC2")
# library(EMC2)
load_all()
debug(calc_ll_manager)
samplers <- run_emc(samplers, verbose = T, cores_for_chains = 1, cores_per_chain = 1, useC = T)
debug(calc_ll_manager)
samplers <- run_emc(samplers, verbose = T, cores_for_chains = 1, cores_per_chain = 1, useC = T)
ll_func
attr(dadm, "model")
attr(dadm)
attributes(dadm)
dadm
debug(calc_ll_manager)
samplers <- run_emc(samplers, verbose = T, cores_for_chains = 1, cores_per_chain = 1, useC = T)
function(proposals, dadm, useC, ll_func, component = NULL){
if(ll_func == log_likelihood_joint){
lls <- log_likelihood_joint(proposals, dadm, component, useC)
} else{
c_name <- attr(dadm,"model")()$c_name
if(is.null(c_name) | !useC){ # use the R implementation
lls <- apply(proposals,1, ll_func,dadm = dadm)
} else{
p_types <- attr(dadm,"model")()$p_types
designs <- list()
for(p in p_types){
designs[[p]] <- attr(dadm,"designs")[[p]][attr(attr(dadm,"designs")[[p]],"expand"),,drop=FALSE]
}
constants <- attr(dadm, "constants")
if(is.null(constants)) constants <- NA
n_trials = nrow(dadm)
lls <- calc_ll(proposals, dadm, constants = constants, n_trials = n_trials, designs = designs, type = c_name, p_types = p_types,
min_ll = log(1e-10), winner = dadm$winner, expand = attr(dadm, "expand"))
}
}
return(lls)
}
samplers <- make_samplers(list(dat, dat), list(design_test, design_test), type = "standard", n_chains = 3)
debug(calc_ll_manager)
load_all()
debug(calc_ll_manager)
samplers <- run_emc(samplers, verbose = T, cores_for_chains = 1, cores_per_chain = 1, useC = T)
debug(log_likelihood_joint)
parPrefix
load_all()
samplers <- make_samplers(list(dat, dat), list(design_test, design_test), type = "standard", n_chains = 3)
debug(calc_ll_manager)
samplers <- run_emc(samplers, verbose = T, cores_for_chains = 1, cores_per_chain = 1, useC = T)
dadm
is.list(dadm)
is.data.frame(dadm)
load_all()
samplers <- make_samplers(list(dat, dat), list(design_test, design_test), type = "standard", n_chains = 3)
debug(calc_ll_manager)
samplers <- run_emc(samplers, verbose = T, cores_for_chains = 1, cores_per_chain = 1, useC = T)
rm(list = ls())
library(devtools)
# Rcpp only works as fast with install like this unfortunately, if this throws errors, restarting Rstudio worked for me
devtools::install("~/Documents/UVA/2022/EMC2")
library(EMC2)
# load_all()
library(tidyverse)
library(extraDistr)
I <- 25 # nr of subjects
J <- 400 # trials
K <- 2 # nr of accumulators/response options
Y <- array(NA, c(J,K,I)) # two accumulators
mu_psi <- 0.28 # non-decision time/shift
sigma_psi <- 0.02
mu_drift_match <- 4
sigma_drift_match <- 0.35
mu_drift_mismatch <- 1
sigma_drift_mismatch <- 0.35
mu_sigma <- 0.7
sigma_sigma <- 0.15
boundary <- 1
drift_match <- numeric(I)
drift_mismatch <- numeric(I)
sigma <- numeric(I)
psi <- numeric(I)
for(i in 1:I) {
drift_match[i] <- rnorm(1, mu_drift_match, sigma_drift_match)
drift_mismatch[i] <- rnorm(1, mu_drift_mismatch, sigma_drift_mismatch)
sigma[i] <- rnorm(1, mu_sigma, sigma_sigma)
psi[i] <- rtnorm(1, mean = mu_psi, sd = sigma_psi, a = 0)
}
dat <- data.frame(I = rep(1:I, each = J),
m = rep(NA, I*J),
t = rep(NA, I*J))
for(i in 1:I){
for(j in 1:J){
Y[j,1,i] <- rwald(1, mu = boundary/drift_match[i], lambda = (boundary/sigma[i])^2)
Y[j,2,i] <- rwald(1, mu = boundary/drift_mismatch[i], lambda = (boundary/sigma[i])^2)
dat[dat$I==i,"t"][j] <- psi[i] + min(Y[j,,i])
dat[dat$I==i,"m"][j] <- which.min(Y[j,,i])
}
}
colnames(dat) <- c("subjects", "R", "rt")
dat$R <- as.factor(dat$R)
dat$subjects <- as.factor(dat$subjects)
library(devtools)
load_all()
rm(list = ls())
library(devtools)
# Rcpp only works as fast with install like this unfortunately, if this throws errors, restarting Rstudio worked for me
devtools::install("~/Documents/UVA/2022/EMC2")
library(EMC2)
# load_all()
library(tidyverse)
library(extraDistr)
I <- 25 # nr of subjects
J <- 400 # trials
K <- 2 # nr of accumulators/response options
Y <- array(NA, c(J,K,I)) # two accumulators
mu_psi <- 0.28 # non-decision time/shift
sigma_psi <- 0.02
mu_drift_match <- 4
sigma_drift_match <- 0.35
mu_drift_mismatch <- 1
sigma_drift_mismatch <- 0.35
mu_sigma <- 0.7
sigma_sigma <- 0.15
boundary <- 1
drift_match <- numeric(I)
drift_mismatch <- numeric(I)
sigma <- numeric(I)
psi <- numeric(I)
for(i in 1:I) {
drift_match[i] <- rnorm(1, mu_drift_match, sigma_drift_match)
drift_mismatch[i] <- rnorm(1, mu_drift_mismatch, sigma_drift_mismatch)
sigma[i] <- rnorm(1, mu_sigma, sigma_sigma)
psi[i] <- rtnorm(1, mean = mu_psi, sd = sigma_psi, a = 0)
}
dat <- data.frame(I = rep(1:I, each = J),
m = rep(NA, I*J),
t = rep(NA, I*J))
for(i in 1:I){
for(j in 1:J){
Y[j,1,i] <- rwald(1, mu = boundary/drift_match[i], lambda = (boundary/sigma[i])^2)
Y[j,2,i] <- rwald(1, mu = boundary/drift_mismatch[i], lambda = (boundary/sigma[i])^2)
dat[dat$I==i,"t"][j] <- psi[i] + min(Y[j,,i])
dat[dat$I==i,"m"][j] <- which.min(Y[j,,i])
}
}
colnames(dat) <- c("subjects", "R", "rt")
dat$R <- as.factor(dat$R)
dat$subjects <- as.factor(dat$subjects)
library(devtools)
load_all()
# Mu varies by stimulus, emphasis, and latent match
design_test <- make_design(
Ffactors=list(subjects=levels(dat$subjects)),
Rlevels=levels(dat$R),
Flist=list(v~R,B~1,s~1,t0~1, A ~ 1),
constants=c(B=log(1), A = log(0)),
model=rdmB)
samplers <- make_samplers(list(dat, dat), list(design_test, design_test), type = "standard", n_chains = 3)
samplers <- run_emc(samplers, verbose = T, cores_for_chains = 1, cores_per_chain = 1, useC = T)
samplers <- run_samplers(samplers, stage = "preburn", iters = 100, verbose = T, cores_for_chains = 1, cores_per_chain = 1, useC = T)
samplers <- run_samplers(samplers, stage = "preburn", iter = 100, verbose = T, cores_for_chains = 1, cores_per_chain = 1, useC = T)
samplers <- make_samplers(list(dat, dat), list(design_test, design_test), type = "standard", n_chains = 3)
system.time(
samplers <- run_samplers(samplers, stage = "preburn", iter = 100, verbose = T, cores_for_chains = 3, cores_per_chain = 2, useC = T)
)
samplers <- make_samplers(list(dat), list(design_test), type = "standard", n_chains = 3)
system.time(
samplers <- run_samplers(samplers, stage = "preburn", iter = 100, verbose = T, cores_for_chains = 3, cores_per_chain = 2, useC = T)
)
samplers <- make_samplers(list(dat), list(design_test), type = "standard", n_chains = 3)
microbenchmark::microbenchmark(
samplers <- run_samplers(samplers, stage = "preburn", iter = 100, verbose = T, cores_for_chains = 3, cores_per_chain = 2, useC = T),
times = 3
)
samplers <- make_samplers(list(dat, dat), list(design_test, design_test), type = "standard", n_chains = 3)
microbenchmark::microbenchmark(
samplers <- run_samplers(samplers, stage = "preburn", iter = 100, verbose = T, cores_for_chains = 3, cores_per_chain = 2, useC = T),
times = 3
)
dat_single <- dat[which(dat$subjects %in% (unique(dat$subjects)[1])),]
dat_single <- droplevels(dat_single)
samplers <- make_samplers(list(dat_single, dat_single), list(design_test, design_test), type = "standard", n_chains = 3)
microbenchmark::microbenchmark(
samplers <- run_samplers(samplers, stage = "preburn", iter = 100, verbose = T, cores_for_chains = 3, cores_per_chain = 1, useC = T),
times = 3
)
dat_single <- dat[which(dat$subjects %in% (unique(dat$subjects)[1])),]
dat_single <- droplevels(dat_single)
samplers <- make_samplers(list(dat_single, dat_single), list(design_test, design_test), type = "single", n_chains = 3)
microbenchmark::microbenchmark(
samplers <- run_samplers(samplers, stage = "preburn", iter = 100, verbose = T, cores_for_chains = 3, cores_per_chain = 1, useC = T),
times = 3
)
dat_single <- dat[which(dat$subjects %in% (unique(dat$subjects)[1])),]
dat_single <- droplevels(dat_single)
samplers <- make_samplers(list(dat_single), list(design_test), type = "single", n_chains = 3)
microbenchmark::microbenchmark(
samplers <- run_samplers(samplers, stage = "preburn", iter = 100, verbose = T, cores_for_chains = 3, cores_per_chain = 1, useC = T),
times = 3
)
rm(list = ls())
library(devtools)
# Rcpp only works as fast with install like this unfortunately, if this throws errors, restarting Rstudio worked for me
devtools::install("~/Documents/UVA/2022/EMC2")
usethis::use_rcpp_armadillo()
rm(list = ls())
library(devtools)
# Rcpp only works as fast with install like this unfortunately, if this throws errors, restarting Rstudio worked for me
devtools::install("~/Documents/UVA/2022/EMC2")
rm(list = ls())
library(devtools)
# Rcpp only works as fast with install like this unfortunately, if this throws errors, restarting Rstudio worked for me
devtools::install("~/Documents/UVA/2022/EMC2")
library(EMC2)
# load_all()
library(tidyverse)
library(extraDistr)
I <- 25 # nr of subjects
J <- 400 # trials
K <- 2 # nr of accumulators/response options
Y <- array(NA, c(J,K,I)) # two accumulators
mu_psi <- 0.28 # non-decision time/shift
sigma_psi <- 0.02
mu_drift_match <- 4
sigma_drift_match <- 0.35
mu_drift_mismatch <- 1
sigma_drift_mismatch <- 0.35
mu_sigma <- 0.7
sigma_sigma <- 0.15
boundary <- 1
drift_match <- numeric(I)
drift_mismatch <- numeric(I)
sigma <- numeric(I)
psi <- numeric(I)
for(i in 1:I) {
drift_match[i] <- rnorm(1, mu_drift_match, sigma_drift_match)
drift_mismatch[i] <- rnorm(1, mu_drift_mismatch, sigma_drift_mismatch)
sigma[i] <- rnorm(1, mu_sigma, sigma_sigma)
psi[i] <- rtnorm(1, mean = mu_psi, sd = sigma_psi, a = 0)
}
dat <- data.frame(I = rep(1:I, each = J),
m = rep(NA, I*J),
t = rep(NA, I*J))
for(i in 1:I){
for(j in 1:J){
Y[j,1,i] <- rwald(1, mu = boundary/drift_match[i], lambda = (boundary/sigma[i])^2)
Y[j,2,i] <- rwald(1, mu = boundary/drift_mismatch[i], lambda = (boundary/sigma[i])^2)
dat[dat$I==i,"t"][j] <- psi[i] + min(Y[j,,i])
dat[dat$I==i,"m"][j] <- which.min(Y[j,,i])
}
}
colnames(dat) <- c("subjects", "R", "rt")
dat$R <- as.factor(dat$R)
dat$subjects <- as.factor(dat$subjects)
library(devtools)
load_all()
rm(list = ls())
library(devtools)
# Rcpp only works as fast with install like this unfortunately, if this throws errors, restarting Rstudio worked for me
devtools::install("~/Documents/UVA/2022/EMC2")
library(EMC2)
# load_all()
library(tidyverse)
library(extraDistr)
I <- 25 # nr of subjects
J <- 400 # trials
K <- 2 # nr of accumulators/response options
Y <- array(NA, c(J,K,I)) # two accumulators
mu_psi <- 0.28 # non-decision time/shift
sigma_psi <- 0.02
mu_drift_match <- 4
sigma_drift_match <- 0.35
mu_drift_mismatch <- 1
sigma_drift_mismatch <- 0.35
mu_sigma <- 0.7
sigma_sigma <- 0.15
boundary <- 1
drift_match <- numeric(I)
drift_mismatch <- numeric(I)
sigma <- numeric(I)
psi <- numeric(I)
for(i in 1:I) {
drift_match[i] <- rnorm(1, mu_drift_match, sigma_drift_match)
drift_mismatch[i] <- rnorm(1, mu_drift_mismatch, sigma_drift_mismatch)
sigma[i] <- rnorm(1, mu_sigma, sigma_sigma)
psi[i] <- rtnorm(1, mean = mu_psi, sd = sigma_psi, a = 0)
}
dat <- data.frame(I = rep(1:I, each = J),
m = rep(NA, I*J),
t = rep(NA, I*J))
for(i in 1:I){
for(j in 1:J){
Y[j,1,i] <- rwald(1, mu = boundary/drift_match[i], lambda = (boundary/sigma[i])^2)
Y[j,2,i] <- rwald(1, mu = boundary/drift_mismatch[i], lambda = (boundary/sigma[i])^2)
dat[dat$I==i,"t"][j] <- psi[i] + min(Y[j,,i])
dat[dat$I==i,"m"][j] <- which.min(Y[j,,i])
}
}
colnames(dat) <- c("subjects", "R", "rt")
dat$R <- as.factor(dat$R)
dat$subjects <- as.factor(dat$subjects)
library(devtools)
#### Models -----
# Mu varies by stimulus, emphasis, and latent match
design_test <- make_design(
Ffactors=list(subjects=levels(dat$subjects)),
Rlevels=levels(dat$R),
Flist=list(v~R,B~1,s~1,t0~1, A ~ 1),
constants=c(B=log(1), A = log(0)),
model=rdmB)
dat_single <- dat[which(dat$subjects %in% (unique(dat$subjects)[1])),]
dat_single <- droplevels(dat_single)
samplers <- make_samplers(list(dat_single), list(design_test), type = "single", n_chains = 3)
microbenchmark::microbenchmark(
samplers <- run_samplers(samplers, stage = "preburn", iter = 100, verbose = T, cores_for_chains = 3, cores_per_chain = 1, useC = T),
times = 3
)
samplers <- make_samplers(list(dat_single, dat_single), list(design_test, design_test), type = "single", n_chains = 3)
microbenchmark::microbenchmark(
samplers <- run_samplers(samplers, stage = "preburn", iter = 100, verbose = T, cores_for_chains = 3, cores_per_chain = 1, useC = T),
times = 3
)
samplers <- make_samplers(list(dat_single, dat_single, dat_single), list(design_test, design_test, design_test), type = "single", n_chains = 3)
microbenchmark::microbenchmark(
samplers <- run_samplers(samplers, stage = "preburn", iter = 100, verbose = T, cores_for_chains = 3, cores_per_chain = 1, useC = T),
times = 3
)
rm(list = ls())
library(devtools)
# Rcpp only works as fast with install like this unfortunately, if this throws errors, restarting Rstudio worked for me
devtools::install("~/Documents/UVA/2022/EMC2")
library(EMC2)
# load_all()
library(tidyverse)
library(extraDistr)
I <- 25 # nr of subjects
J <- 400 # trials
K <- 2 # nr of accumulators/response options
Y <- array(NA, c(J,K,I)) # two accumulators
mu_psi <- 0.28 # non-decision time/shift
sigma_psi <- 0.02
mu_drift_match <- 4
sigma_drift_match <- 0.35
mu_drift_mismatch <- 1
sigma_drift_mismatch <- 0.35
mu_sigma <- 0.7
sigma_sigma <- 0.15
boundary <- 1
drift_match <- numeric(I)
drift_mismatch <- numeric(I)
sigma <- numeric(I)
psi <- numeric(I)
for(i in 1:I) {
drift_match[i] <- rnorm(1, mu_drift_match, sigma_drift_match)
drift_mismatch[i] <- rnorm(1, mu_drift_mismatch, sigma_drift_mismatch)
sigma[i] <- rnorm(1, mu_sigma, sigma_sigma)
psi[i] <- rtnorm(1, mean = mu_psi, sd = sigma_psi, a = 0)
}
dat <- data.frame(I = rep(1:I, each = J),
m = rep(NA, I*J),
t = rep(NA, I*J))
for(i in 1:I){
for(j in 1:J){
Y[j,1,i] <- rwald(1, mu = boundary/drift_match[i], lambda = (boundary/sigma[i])^2)
Y[j,2,i] <- rwald(1, mu = boundary/drift_mismatch[i], lambda = (boundary/sigma[i])^2)
dat[dat$I==i,"t"][j] <- psi[i] + min(Y[j,,i])
dat[dat$I==i,"m"][j] <- which.min(Y[j,,i])
}
}
colnames(dat) <- c("subjects", "R", "rt")
dat$R <- as.factor(dat$R)
dat$subjects <- as.factor(dat$subjects)
library(devtools)
#### Models -----
# Mu varies by stimulus, emphasis, and latent match
design_test <- make_design(
Ffactors=list(subjects=levels(dat$subjects)),
Rlevels=levels(dat$R),
Flist=list(v~R,B~1,s~1,t0~1, A ~ 1),
constants=c(B=log(1), A = log(0)),
model=rdmB)
rm(list = ls())
library(devtools)
# Rcpp only works as fast with install like this unfortunately, if this throws errors, restarting Rstudio worked for me
devtools::install("~/Documents/UVA/2022/EMC2")
library(EMC2)
# load_all()
library(tidyverse)
library(extraDistr)
I <- 25 # nr of subjects
J <- 400 # trials
K <- 2 # nr of accumulators/response options
Y <- array(NA, c(J,K,I)) # two accumulators
mu_psi <- 0.28 # non-decision time/shift
sigma_psi <- 0.02
mu_drift_match <- 4
sigma_drift_match <- 0.35
mu_drift_mismatch <- 1
sigma_drift_mismatch <- 0.35
mu_sigma <- 0.7
sigma_sigma <- 0.15
boundary <- 1
drift_match <- numeric(I)
drift_mismatch <- numeric(I)
sigma <- numeric(I)
psi <- numeric(I)
for(i in 1:I) {
drift_match[i] <- rnorm(1, mu_drift_match, sigma_drift_match)
drift_mismatch[i] <- rnorm(1, mu_drift_mismatch, sigma_drift_mismatch)
sigma[i] <- rnorm(1, mu_sigma, sigma_sigma)
psi[i] <- rtnorm(1, mean = mu_psi, sd = sigma_psi, a = 0)
}
dat <- data.frame(I = rep(1:I, each = J),
m = rep(NA, I*J),
t = rep(NA, I*J))
for(i in 1:I){
for(j in 1:J){
Y[j,1,i] <- rwald(1, mu = boundary/drift_match[i], lambda = (boundary/sigma[i])^2)
Y[j,2,i] <- rwald(1, mu = boundary/drift_mismatch[i], lambda = (boundary/sigma[i])^2)
dat[dat$I==i,"t"][j] <- psi[i] + min(Y[j,,i])
dat[dat$I==i,"m"][j] <- which.min(Y[j,,i])
}
}
colnames(dat) <- c("subjects", "R", "rt")
dat$R <- as.factor(dat$R)
dat$subjects <- as.factor(dat$subjects)
library(devtools)
#### Models -----
# Mu varies by stimulus, emphasis, and latent match
design_test <- make_design(
Ffactors=list(subjects=levels(dat$subjects)),
Rlevels=levels(dat$R),
Flist=list(v~R,B~1,s~1,t0~1, A ~ 1),
constants=c(B=log(1), A = log(0)),
model=rdmB)
dat_single <- dat[which(dat$subjects %in% (unique(dat$subjects)[1])),]
dat_single <- droplevels(dat_single)
samplers <- make_samplers(list(dat_single, dat_single, dat_single), list(design_test, design_test, design_test), type = "single", n_chains = 3)
microbenchmark::microbenchmark(
samplers <- run_samplers(samplers, stage = "preburn", iter = 100, verbose = T, cores_for_chains = 3, cores_per_chain = 1, useC = T),
times = 3
)
rm(list = ls())
library(devtools)
# Rcpp only works as fast with install like this unfortunately, if this throws errors, restarting Rstudio worked for me
devtools::install("~/Documents/UVA/2022/EMC2")
library(EMC2)
# load_all()
load("test_files/PNAS.RData")
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
# Average rate = intercept, and rate d = difference (match-mismatch) contrast
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
design_RDM <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Clist=list(lM=ADmat,lR=ADmat,S=ADmat,E=Emat),
Flist=list(v~lM,s~1,B~E,A~1,t0~1),
constants=c(s=log(1)),
model=rdmB)
