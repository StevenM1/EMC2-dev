all_data <- list()
for (i in sort(ucells)) {
tmp_data <- data[cells == i,]
tmp_pars <- pars[parcells == i,]
vs[[i]] <- mean(tmp_pars$v)
bs[[i]] <- mean(tmp_pars$b)
t0s[[i]] <- mean(tmp_pars$t0)
all_data[[i]] <- tmp_data
}
vs <- get_unq_names(unlist(vs))
bs <- get_unq_names(unlist(bs))
t0s <- get_unq_names(unlist(t0s))
free_v <- !duplicated(vs)
free_b <- !duplicated(bs)
all_id_names <- unique(c(names(vs[free_v]), names(bs[free_b])))
cols <- c("#8C2E89","#116214", "#D68E07","#200BA5",  "#02C6B2", "#C60202", "#788714", "#D33A7C") #colorspace::qualitative_hcl(length(all_id_names), "Pastel 1", c = 120)
names(cols) <- all_id_names
denses <- lapply(all_data, function(x) density(x$rt))
t0 <- mean(t0s)
x <- c(0, t0)
y <- c(0, 0)
tops <- numeric(length(denses))
for(i in 1:length(denses)){
denses[[i]]$y <- denses[[i]]$y*pR[i]*squash_dens + bs[i] + max(bs)/75
}
ylim <- c(-.1, max(sapply(denses, function(x) max(x$y))))
max_rt <- quantile(data$rt, .975)
plot(x, y, type = "l", xlim = c(0, max_rt), xlab = "", ylab = "", axes = F, ylim = ylim, lwd = 3, main = main)
arrows(x0 = 0, x1 = max_rt, y0 = -.1, y1 = -.1, lwd = 3, length = .1)
if(sum(free_v) != 1){
dens_free <- free_v
names_dens <- names(vs)
} else{
dens_free <- free_b
names_dens <- names(bs)
}
for(i in 1:length(all_data)){
if(free_b[i]) lines(c(0, max_rt), c(bs[i], bs[i]), lwd = 3,
lty = 2, col = get_cols(cols, free_b, i, names(bs)[i]))
rt <- min(bs)/vs[i] + t0
if(free_v[i]) arrows(x0 = t0, x1 = rt, y0 = 0, y1 = min(bs)-.05, lwd = 3,
length = .1, col = get_cols(cols, free_v, i, names(vs)[i]))
lines(denses[[i]], lwd = 3, col = adjustcolor(get_cols(cols, dens_free, i, names_dens[i])))
polygon(denses[[i]], col = adjustcolor(get_cols(cols, dens_free, i, names_dens[i]), alpha.f = alpha))
}
if(sum(free_v) != 1){
legend(-.1, min(bs) - min(bs)/10, legend = names(vs[free_v]), title = "v", lty = 1, lwd = 3, col = cols[names(vs[free_v])],
cex = 1, bty = "n", inset = c(0, .05), title.cex = 1.25, title.adj = .2)
} else{
text(rt*.6 - min(bs)/50, (rt-t0)*.6*vs[1] + min(bs)/50, "v", cex = 1.5, srt = get_drift_angle(t0, rt, 0, min(bs) - .05))
}
text(t0/2, min(bs)/10, "t0", cex = 1.5)
if(sum(free_b) != 1 & !identical(names(bs)[free_b], names(vs)[free_v])){
legend("bottomright", legend = names(bs[free_b]), title = "b", lty = 1, lwd = 3, col = cols[names(bs[free_b])],
cex = 1, bty = "n", inset = c(.05, .05), title.adj = .2, title.cex = 1.5)
}
title(xlab="RT", line=0, cex.lab = 1.5)
}
# undebug(make_lba_plot_helper)
par(mfrow = c(1,2))
for (i in sort(ucells)) {
tmp_data <- dadm[cells == i,]
tmp_pars <- pars[parcells == i,]
make_lba_plot_helper(tmp_data, tmp_pars, vary_factor, main = i)
}
devtools::document()
devtools::document()
?prior
devtools::document()
?prior
?prior
devtools::document()
?get_prior
?prior
?subset.emc
devtools::document()
devtools::document()
subset(samplers_LNR, length.out = 10)
test <- subset(samplers_LNR, length.out = 10)
test
test[[1]]$samples$theta_mu
devtools::document()
?subset
devtools::document()
devtools::document()
?posterior_summary
?posterior_samples
?posterior_summary
?posterior_summary
?ess_summary
devtools::document()
?ess_summary
?hypothesis
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::load_all()
devtools::document()
devtools::test()
devtools::load_all()
devtools::load_all()
devtools::load_all()
# When working with lM it is useful to design  an "average and difference"
# contrast matrix, which for binary responses has a simple canonical from:
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# We also define a match function for lM
matchfun=function(d)d$S==d$lR
# Drop most subjects
dat <- forstmann[forstmann$subjects %in% unique(forstmann$subjects)[1:2],]
dat$subjects <- droplevels(dat$subjects)
design_LNR <- design(data = dat,model=LNR,matchfun=matchfun,
formula=list(m~lM,s~1,t0~1),
contrasts=list(m=list(lM=ADmat)))
# create emc objects for the different types
LNR_factor <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "factor",
n_factors = 2)
LNR_diag <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "diagonal")
LNR_blocked <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "blocked",
par_groups = c(1,2,3,3))
LNR_single <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "single")
# Set seed for mclapply
RNGkind("L'Ecuyer-CMRG")
set.seed(123)
# Run the models for the different variants
# Only preburn, so bit risky since adapt could fail
N <- 50
LNR_factor <- init_chains(LNR_factor, cores_for_chains = 1, particles = 10)
LNR_factor <- run_emc(LNR_factor, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_diag <- init_chains(LNR_diag, cores_for_chains = 1, particles = 10)
LNR_diag <- run_emc(LNR_diag, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_blocked <- init_chains(LNR_blocked, cores_for_chains = 1, particles = 10)
LNR_blocked <- run_emc(LNR_blocked, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_single <- init_chains(LNR_single, cores_for_chains = 1, particles = 10)
LNR_single <- run_emc(LNR_single, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1)
IC()
debug(IC)
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1)
attr(emc[[1]], "variant_funs")
attr(emc[[1]], "variant_funs")$group_IC
attr(emc[[1]], "variant_funs")$group_IC(emc, filter=filter,subfilter=subfilter)
devtools::load_all()
# When working with lM it is useful to design  an "average and difference"
# contrast matrix, which for binary responses has a simple canonical from:
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# We also define a match function for lM
matchfun=function(d)d$S==d$lR
# Drop most subjects
dat <- forstmann[forstmann$subjects %in% unique(forstmann$subjects)[1:2],]
dat$subjects <- droplevels(dat$subjects)
design_LNR <- design(data = dat,model=LNR,matchfun=matchfun,
formula=list(m~lM,s~1,t0~1),
contrasts=list(m=list(lM=ADmat)))
# create emc objects for the different types
LNR_factor <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "factor",
n_factors = 2)
LNR_diag <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "diagonal")
LNR_blocked <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "blocked",
par_groups = c(1,2,3,3))
LNR_single <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "single")
# When working with lM it is useful to design  an "average and difference"
# contrast matrix, which for binary responses has a simple canonical from:
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# We also define a match function for lM
matchfun=function(d)d$S==d$lR
# Drop most subjects
dat <- forstmann[forstmann$subjects %in% unique(forstmann$subjects)[1:2],]
dat$subjects <- droplevels(dat$subjects)
design_LNR <- design(data = dat,model=LNR,matchfun=matchfun,
formula=list(m~lM,s~1,t0~1),
contrasts=list(m=list(lM=ADmat)))
# create emc objects for the different types
LNR_factor <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "factor",
n_factors = 2)
LNR_diag <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "diagonal")
LNR_blocked <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "blocked",
par_groups = c(1,2,3,3))
LNR_single <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "single")
# Set seed for mclapply
RNGkind("L'Ecuyer-CMRG")
set.seed(123)
# Run the models for the different variants
# Only preburn, so bit risky since adapt could fail
N <- 50
LNR_factor <- init_chains(LNR_factor, cores_for_chains = 1, particles = 10)
LNR_factor <- run_emc(LNR_factor, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_diag <- init_chains(LNR_diag, cores_for_chains = 1, particles = 10)
LNR_diag <- run_emc(LNR_diag, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_blocked <- init_chains(LNR_blocked, cores_for_chains = 1, particles = 10)
LNR_blocked <- run_emc(LNR_blocked, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_single <- init_chains(LNR_single, cores_for_chains = 1, particles = 10)
LNR_single <- run_emc(LNR_single, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1),
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1)
devtools::load_all()
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1)
# When working with lM it is useful to design  an "average and difference"
# contrast matrix, which for binary responses has a simple canonical from:
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# We also define a match function for lM
matchfun=function(d)d$S==d$lR
# Drop most subjects
dat <- forstmann[forstmann$subjects %in% unique(forstmann$subjects)[1:2],]
dat$subjects <- droplevels(dat$subjects)
design_LNR <- design(data = dat,model=LNR,matchfun=matchfun,
formula=list(m~lM,s~1,t0~1),
contrasts=list(m=list(lM=ADmat)))
# create emc objects for the different types
LNR_factor <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "factor",
n_factors = 2)
LNR_diag <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "diagonal")
LNR_blocked <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "blocked",
par_groups = c(1,2,3,3))
LNR_single <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "single")
# Set seed for mclapply
RNGkind("L'Ecuyer-CMRG")
set.seed(123)
# Run the models for the different variants
# Only preburn, so bit risky since adapt could fail
N <- 50
LNR_factor <- init_chains(LNR_factor, cores_for_chains = 1, particles = 10)
LNR_factor <- run_emc(LNR_factor, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_diag <- init_chains(LNR_diag, cores_for_chains = 1, particles = 10)
LNR_diag <- run_emc(LNR_diag, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_blocked <- init_chains(LNR_blocked, cores_for_chains = 1, particles = 10)
LNR_blocked <- run_emc(LNR_blocked, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_single <- init_chains(LNR_single, cores_for_chains = 1, particles = 10)
LNR_single <- run_emc(LNR_single, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1)
debug(get_objects_factor)
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1)
selection
# When working with lM it is useful to design  an "average and difference"
# contrast matrix, which for binary responses has a simple canonical from:
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# We also define a match function for lM
matchfun=function(d)d$S==d$lR
# Drop most subjects
dat <- forstmann[forstmann$subjects %in% unique(forstmann$subjects)[1:2],]
dat$subjects <- droplevels(dat$subjects)
design_LNR <- design(data = dat,model=LNR,matchfun=matchfun,
formula=list(m~lM,s~1,t0~1),
contrasts=list(m=list(lM=ADmat)))
# create emc objects for the different types
LNR_factor <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "factor",
n_factors = 2)
LNR_diag <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "diagonal")
LNR_blocked <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "blocked",
par_groups = c(1,2,3,3))
LNR_single <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "single")
# Set seed for mclapply
RNGkind("L'Ecuyer-CMRG")
set.seed(123)
# Run the models for the different variants
# Only preburn, so bit risky since adapt could fail
N <- 50
LNR_factor <- init_chains(LNR_factor, cores_for_chains = 1, particles = 10)
LNR_factor <- run_emc(LNR_factor, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_diag <- init_chains(LNR_diag, cores_for_chains = 1, particles = 10)
LNR_diag <- run_emc(LNR_diag, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_blocked <- init_chains(LNR_blocked, cores_for_chains = 1, particles = 10)
LNR_blocked <- run_emc(LNR_blocked, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_single <- init_chains(LNR_single, cores_for_chains = 1, particles = 10)
LNR_single <- run_emc(LNR_single, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1)
devtools::load_all()
# When working with lM it is useful to design  an "average and difference"
# contrast matrix, which for binary responses has a simple canonical from:
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# We also define a match function for lM
matchfun=function(d)d$S==d$lR
# Drop most subjects
dat <- forstmann[forstmann$subjects %in% unique(forstmann$subjects)[1:2],]
dat$subjects <- droplevels(dat$subjects)
design_LNR <- design(data = dat,model=LNR,matchfun=matchfun,
formula=list(m~lM,s~1,t0~1),
contrasts=list(m=list(lM=ADmat)))
# create emc objects for the different types
LNR_factor <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "factor",
n_factors = 2)
LNR_diag <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "diagonal")
LNR_blocked <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "blocked",
par_groups = c(1,2,3,3))
LNR_single <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "single")
# Set seed for mclapply
RNGkind("L'Ecuyer-CMRG")
set.seed(123)
# Run the models for the different variants
# Only preburn, so bit risky since adapt could fail
N <- 50
LNR_factor <- init_chains(LNR_factor, cores_for_chains = 1, particles = 10)
LNR_factor <- run_emc(LNR_factor, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_diag <- init_chains(LNR_diag, cores_for_chains = 1, particles = 10)
LNR_diag <- run_emc(LNR_diag, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_blocked <- init_chains(LNR_blocked, cores_for_chains = 1, particles = 10)
LNR_blocked <- run_emc(LNR_blocked, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_single <- init_chains(LNR_single, cores_for_chains = 1, particles = 10)
LNR_single <- run_emc(LNR_single, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1)
debug(ess_summary.emc)
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1)
debug(get_summary_stat)
dots
do.call(get_pars, c(list(emc = emc, selection = selection), fix_dots(dots, get_pars)))
# When working with lM it is useful to design  an "average and difference"
# contrast matrix, which for binary responses has a simple canonical from:
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# We also define a match function for lM
matchfun=function(d)d$S==d$lR
# Drop most subjects
dat <- forstmann[forstmann$subjects %in% unique(forstmann$subjects)[1:2],]
dat$subjects <- droplevels(dat$subjects)
design_LNR <- design(data = dat,model=LNR,matchfun=matchfun,
formula=list(m~lM,s~1,t0~1),
contrasts=list(m=list(lM=ADmat)))
# create emc objects for the different types
LNR_factor <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "factor",
n_factors = 2)
LNR_diag <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "diagonal")
LNR_blocked <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "blocked",
par_groups = c(1,2,3,3))
LNR_single <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "single")
# Set seed for mclapply
RNGkind("L'Ecuyer-CMRG")
set.seed(123)
# Run the models for the different variants
# Only preburn, so bit risky since adapt could fail
N <- 50
LNR_factor <- init_chains(LNR_factor, cores_for_chains = 1, particles = 10)
LNR_factor <- run_emc(LNR_factor, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_diag <- init_chains(LNR_diag, cores_for_chains = 1, particles = 10)
LNR_diag <- run_emc(LNR_diag, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_blocked <- init_chains(LNR_blocked, cores_for_chains = 1, particles = 10)
LNR_blocked <- run_emc(LNR_blocked, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_single <- init_chains(LNR_single, cores_for_chains = 1, particles = 10)
LNR_single <- run_emc(LNR_single, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1)
debug(run_bridge_sampling)
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1),
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1)
devtools::load_all()
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1)
debug(IC)
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", BayesFactor = F)
Dmeans
minDs
mean_lls
mean_pars_lls
mean_pars
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1)
ll
emc[[1]]$samples$alpha
mean_lls
alpha
ll
length(alpha)
alpha
debug(get_pars)
get_pars(emc,selection="alpha",filter=filter,subfilter=subfilter, by_subject = TRUE, merge_chains = TRUE)
subject
samples
subnames
samples
apply(samples, 2, sd)
samples
devtools::load_all()
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", BayesFactor = F)
debug(filter_const_and_dup)
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", BayesFactor = F)
x
devtools::load_all()
debug(filter_const_and_dup)
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", BayesFactor = F)
dim(samples[[1]])
samples
x
devtools::load_all()
debug(IC)
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", BayesFactor = F)
mean_pars_lls
devtools::load_all()
debug(IC)
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", BayesFactor = F)
debug(get_pars)
samples
filter_const_and_dup(samples, remove_dup)
debug(filter_const_and_dup)
filter_const_and_dup(samples, remove_dup)
x
devtools::load_all()
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", BayesFactor = F)
debug(IC)
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", BayesFactor = F)
mean_pars_lls
Dmeans
mean_pars_lls
group_stats
mean_lls
mean_lls
Dmeans
minDs
attr(emc[[1]], "variant_funs")$group_IC(emc, filter=filter,subfilter=subfilter)
debug(attr(emc[[1]], "variant_funs")$group_IC)
attr(emc[[1]], "variant_funs")$group_IC(emc, filter=filter,subfilter=subfilter)
theta_var
get_pars(emc, selection = "sigma2", filter = filter, subfilter = subfilter,
return_mcmc = FALSE, merge_chains = TRUE)
theta_var <- get_pars(emc, selection = "Sigma", filter = filter, subfilter = subfilter,
return_mcmc = FALSE, merge_chains = TRUE, remove_dup = F)
theta_var
debug(get_pars)
theta_var <- get_pars(emc, selection = "Sigma", filter = filter, subfilter = subfilter,
return_mcmc = FALSE, merge_chains = TRUE, remove_dup = F)
remove_dup
samples
debug(filter_const_and_dup)
filter_const_and_dup(samples, remove_dup)
is_constant
devtools::load_all()
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", BayesFactor = F)
.rs.restartR()
devtools::load_all()
debug(group__IC_standard)
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", BayesFactor = F)
devtools::load_all()
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", BayesFactor = F)
debug(IC)
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", BayesFactor = F)
filter
subfilter
attr(emc[[1]], "variant_funs")$group_IC(emc, filter=filter,subfilter=subfilter)
attr(emc[[1]], "variant_funs")$group_IC(emc, filter=filter,subfilter=subfilter)
debug(attr(emc[[1]], "variant_funs")$group_IC)
attr(emc[[1]], "variant_funs")$group_IC(emc, filter=filter,subfilter=subfilter)
get_pars(emc, selection = "alpha", filter = filter, subfilter = subfilter,
return_mcmc = FALSE, merge_chains = TRUE)
debug(get_pars)
get_pars(emc, selection = "alpha", filter = filter, subfilter = subfilter,
return_mcmc = FALSE, merge_chains = TRUE)
devtools::load_all()
attr(samples_LNR[[1]], "variant_funs")
attr(samples_LNR[[1]], "variant_funs")$group_IC
attr(samples_LNR[[1]], "variant_funs") <- get_variant_funs
attr(samples_LNR[[1]], "variant_funs")$group_IC
attr(samples_LNR[[1]], "variant_funs") <- get_variant_funs()
attr(samples_LNR[[1]], "variant_funs")$group_IC
attr(samples_LNR[[2]], "variant_funs") <- get_variant_funs()
attr(samples_LNR[[3]], "variant_funs") <- get_variant_funs()
save(samples_LNR, file = "data/samples_LNR.rda")
.rs.restartR()
.rs.restartR()
devtools::test()
# When working with lM it is useful to design  an "average and difference"
# contrast matrix, which for binary responses has a simple canonical from:
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# We also define a match function for lM
matchfun=function(d)d$S==d$lR
# Drop most subjects
dat <- forstmann[forstmann$subjects %in% unique(forstmann$subjects)[1:2],]
devtools::load_all()
# When working with lM it is useful to design  an "average and difference"
# contrast matrix, which for binary responses has a simple canonical from:
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# We also define a match function for lM
matchfun=function(d)d$S==d$lR
# Drop most subjects
dat <- forstmann[forstmann$subjects %in% unique(forstmann$subjects)[1:2],]
dat$subjects <- droplevels(dat$subjects)
design_LNR <- design(data = dat,model=LNR,matchfun=matchfun,
formula=list(m~lM,s~1,t0~1),
contrasts=list(m=list(lM=ADmat)))
# create emc objects for the different types
LNR_factor <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "factor",
n_factors = 2)
LNR_diag <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "diagonal")
LNR_blocked <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "blocked",
par_groups = c(1,2,3,3))
LNR_single <- make_emc(dat, design_LNR, rt_resolution = 0.05, n_chains = 2, type = "single")
# Set seed for mclapply
RNGkind("L'Ecuyer-CMRG")
set.seed(123)
# Run the models for the different variants
# Only preburn, so bit risky since adapt could fail
N <- 50
LNR_factor <- init_chains(LNR_factor, cores_for_chains = 1, particles = 10)
LNR_factor <- run_emc(LNR_factor, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_diag <- init_chains(LNR_diag, cores_for_chains = 1, particles = 10)
LNR_diag <- run_emc(LNR_diag, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_blocked <- init_chains(LNR_blocked, cores_for_chains = 1, particles = 10)
LNR_blocked <- run_emc(LNR_blocked, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
LNR_single <- init_chains(LNR_single, cores_for_chains = 1, particles = 10)
LNR_single <- run_emc(LNR_single, cores_for_chains = 1, stop_criteria = list(iter = N), stage = "preburn")
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1)
debug(get_idx)
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1),
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1)
stage
debug(IC)
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1)
stage
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1),
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), filter = "preburn", cores_for_props = 1)
stage
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), stage = "preburn", cores_for_props = 1)
f
.rs.restartR()
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), stage = "preburn", cores_for_props = 1)
devtools::load_all()
compare(list(single = LNR_single, diag = LNR_diag, factor = LNR_factor), stage = "preburn", cores_for_props = 1)
