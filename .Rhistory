n_trials <- 100
n_groups <- 2
subject <- rep(1:n_subjects, each = n_trials*n_cond)
cond <- rep(rep(1:n_cond, n_subjects), each = n_trials)
rt <- rnorm(n_subjects * n_trials * n_cond, mean = cond*subject)
df <- data.frame(subjects = subject, cond = cond, rt = rt)
for(i in 2:n_groups){
new_df <- df
new_df$subjects <- new_df$subjects +n_subjects
df <- rbind(df, new_df)
}
df$group <- rep(1:n_groups, each = n_trials*n_cond*n_subjects)
df$subjects <- as.factor(df$subjects)
df$cond <- as.factor(df$cond)
df$group <- as.factor(df$group)
df$R <- as.factor(1)
make_design_lm <- function(Flist,matchfun=NULL,constants=NULL,report_p_vector=TRUE, ddata = NULL, model){
# This will reorder the data for computational purposes! The design matrices will be on the reordered data.
if(is.null(ddata)){
stop("For now, ddata has to be specified in type lm")
}
all_vars <- unique(unlist(lapply(form, FUN = function(x) all.vars(delete.response(terms(x))))))
df_covs <- sapply(df, is.factor)
df_covs <- df_covs[!df_covs]
Fcovariates <- all_vars[!all_vars %in% c("subjects", "RT", "R") & all_vars %in% df_covs]
if(length(Fcovariates == 0)) Fcovariates <- NULL
ddata <- add_accumulators(ddata, matchfun = matchfun, type = model()$type, Fcovariates = Fcovariates)
DM_fixed <- vector("list", length(Flist))
DM_random <- vector("list", length(Flist))
pars_random <- character()
pars_fixed <- character()
g_random <- numeric()
g_fixed <- numeric()
uniques_in_group <- character()
names(DM_fixed) <- lapply(Flist, FUN = function(x) return(x[[2]]))
names(DM_random) <- lapply(Flist, FUN = function(x) return(x[[2]]))
for(form in Flist){
name <- form[[2]]
use <- types_and_baseForm(form)
trms <- use$terms
dataTypes <- use$types
if(length(trms) > 0){ # More than just an intercept
Xs = lapply(trms, function(trm, data, dataTypes) {
oneDM(trm, data = ddata, dataTypes = dataTypes)
}, data = ddata, dataTypes = dataTypes)
DM <- sepFixRandom(Xs, use$types)
par_names_curr <- get_parNames(DM$fixed,DM$random, as.character(name))
colnames(DM$fixed) <- par_names_curr$fixed
colnames(DM$random) <- par_names_curr$random
g <- getGMap(DM, trms, g_fixed, g_random)
DM_random[[name]] <- DM$random
DM_fixed[[name]] <- DM$fixed
g_random <- c(g_random, g$random)
g_fixed <- c(g_fixed, g$fixed)
uniques_in_group <- c(uniques_in_group, par_names_curr$uniques_in_group)
pars_fixed <- c(pars_fixed, par_names_curr$fixed)
pars_random <- c(pars_random, par_names_curr$random)
} else{
pars_fixed <- c(pars_fixed, as.character(name)) # Intercept only
intercept <- as.matrix(rep(1, nrow(ddata)))
colnames(intercept) <- as.character(name)
DM_fixed[[name]] <- intercept
}
}
if (report_p_vector) {
cat("fixed : \n")
cat(pars_fixed, "\n\n")
cat("random per subject : \n")
cat(uniques_in_group)
}
design <- list(
DM_fixed = DM_fixed,
DM_random = DM_random,
constants = constants,
model = model,
Fcovariates = Fcovariates
)
attr(design, "p_vector_fixed") <- pars_fixed[!pars_fixed %in% names(constants)]
attr(design, "p_vector_random") <- pars_random[!pars_random %in% names(constants)]
attr(design, "g_fixed") <- g_fixed
attr(design, "g_random") <- g_random
return(design)
}
form <- list(v~cond + (cond|group/subjects),sv~
1,B~1 + (1|group),A~1,t0~ cond + (cond|subjects))
debug(types_andBaseForm)
debug(types_and_baseForm)
test <- make_design_lm(form, ddata = df, model = ddmTZD)
after_bar
grepl(":", after_bar)
after_bar[grepl(":", after_bar)]
min(c())
?min
min(c(), na.rm = T)
c(NULL, 1)
c(NULL, grepl("A", "b"))
c(NULL, grep("A", "b"))
test <- c("b", "c")
c(NULL, test[grepl("a", test)])
c(NULL, a, test[grepl("a", test)])
c(NULL, "", test[grepl("a", test)])
c(NULL, "a", test[grepl("a", test)])
c(NULL, "a", test[grepl("b", test)])
c(NULL, "a", test[grepl("bc", test)])
rm(list = ls())
devtools::load_all()
source("test_files/utils_lm.R")
library(lme4)
library(BayesFactor)
n_subjects <- 6
n_cond <- 3
n_trials <- 100
n_groups <- 2
subject <- rep(1:n_subjects, each = n_trials*n_cond)
cond <- rep(rep(1:n_cond, n_subjects), each = n_trials)
rt <- rnorm(n_subjects * n_trials * n_cond, mean = cond*subject)
df <- data.frame(subjects = subject, cond = cond, rt = rt)
for(i in 2:n_groups){
new_df <- df
new_df$subjects <- new_df$subjects +n_subjects
df <- rbind(df, new_df)
}
df$group <- rep(1:n_groups, each = n_trials*n_cond*n_subjects)
df$subjects <- as.factor(df$subjects)
df$cond <- as.factor(df$cond)
df$group <- as.factor(df$group)
df$R <- as.factor(1)
make_design_lm <- function(Flist,matchfun=NULL,constants=NULL,report_p_vector=TRUE, ddata = NULL, model){
# This will reorder the data for computational purposes! The design matrices will be on the reordered data.
if(is.null(ddata)){
stop("For now, ddata has to be specified in type lm")
}
all_vars <- unique(unlist(lapply(form, FUN = function(x) all.vars(delete.response(terms(x))))))
df_covs <- sapply(df, is.factor)
df_covs <- df_covs[!df_covs]
Fcovariates <- all_vars[!all_vars %in% c("subjects", "RT", "R") & all_vars %in% df_covs]
if(length(Fcovariates == 0)) Fcovariates <- NULL
ddata <- add_accumulators(ddata, matchfun = matchfun, type = model()$type, Fcovariates = Fcovariates)
DM_fixed <- vector("list", length(Flist))
DM_random <- vector("list", length(Flist))
pars_random <- character()
pars_fixed <- character()
g_random <- numeric()
g_fixed <- numeric()
uniques_in_group <- character()
names(DM_fixed) <- lapply(Flist, FUN = function(x) return(x[[2]]))
names(DM_random) <- lapply(Flist, FUN = function(x) return(x[[2]]))
for(form in Flist){
name <- form[[2]]
use <- types_and_baseForm(form)
trms <- use$terms
dataTypes <- use$types
if(length(trms) > 0){ # More than just an intercept
Xs = lapply(trms, function(trm, data, dataTypes) {
oneDM(trm, data = ddata, dataTypes = dataTypes)
}, data = ddata, dataTypes = dataTypes)
DM <- sepFixRandom(Xs, use$types)
par_names_curr <- get_parNames(DM$fixed,DM$random, as.character(name))
colnames(DM$fixed) <- par_names_curr$fixed
colnames(DM$random) <- par_names_curr$random
g <- getGMap(DM, trms, g_fixed, g_random, use$is_nested)
DM_random[[name]] <- DM$random
DM_fixed[[name]] <- DM$fixed
g_random <- c(g_random, g$random)
g_fixed <- c(g_fixed, g$fixed)
uniques_in_group <- c(uniques_in_group, par_names_curr$uniques_in_group)
pars_fixed <- c(pars_fixed, par_names_curr$fixed)
pars_random <- c(pars_random, par_names_curr$random)
} else{
pars_fixed <- c(pars_fixed, as.character(name)) # Intercept only
intercept <- as.matrix(rep(1, nrow(ddata)))
colnames(intercept) <- as.character(name)
DM_fixed[[name]] <- intercept
if(length(g_fixed) > 0){
g_fixed <- c(g_fixed, max(g_fixed) + 1)
} else{
g_fixed <- 1
}
}
}
if (report_p_vector) {
cat("fixed : \n")
cat(pars_fixed, "\n\n")
cat("random per subject : \n")
cat(uniques_in_group)
}
design <- list(
DM_fixed = DM_fixed,
DM_random = DM_random,
constants = constants,
model = model,
Fcovariates = Fcovariates
)
attr(design, "p_vector_fixed") <- pars_fixed[!pars_fixed %in% names(constants)]
attr(design, "p_vector_random") <- pars_random[!pars_random %in% names(constants)]
attr(design, "g_fixed") <- g_fixed
attr(design, "g_random") <- g_random
return(design)
}
form <- list(v~cond + (cond|group/subjects),sv~
1,B~1 + (1|group),A~1,t0~ cond + (cond|subjects))
debug(make_design_lm)
test <- make_design_lm(form, ddata = df, model = ddmTZD)
use
rm(list = ls())
devtools::load_all()
source("test_files/utils_lm.R")
library(lme4)
library(BayesFactor)
n_subjects <- 6
n_cond <- 3
n_trials <- 100
n_groups <- 2
subject <- rep(1:n_subjects, each = n_trials*n_cond)
cond <- rep(rep(1:n_cond, n_subjects), each = n_trials)
rt <- rnorm(n_subjects * n_trials * n_cond, mean = cond*subject)
df <- data.frame(subjects = subject, cond = cond, rt = rt)
for(i in 2:n_groups){
new_df <- df
new_df$subjects <- new_df$subjects +n_subjects
df <- rbind(df, new_df)
}
df$group <- rep(1:n_groups, each = n_trials*n_cond*n_subjects)
df$subjects <- as.factor(df$subjects)
df$cond <- as.factor(df$cond)
df$group <- as.factor(df$group)
df$R <- as.factor(1)
make_design_lm <- function(Flist,matchfun=NULL,constants=NULL,report_p_vector=TRUE, ddata = NULL, model){
# This will reorder the data for computational purposes! The design matrices will be on the reordered data.
if(is.null(ddata)){
stop("For now, ddata has to be specified in type lm")
}
all_vars <- unique(unlist(lapply(form, FUN = function(x) all.vars(delete.response(terms(x))))))
df_covs <- sapply(df, is.factor)
df_covs <- df_covs[!df_covs]
Fcovariates <- all_vars[!all_vars %in% c("subjects", "RT", "R") & all_vars %in% df_covs]
if(length(Fcovariates == 0)) Fcovariates <- NULL
ddata <- add_accumulators(ddata, matchfun = matchfun, type = model()$type, Fcovariates = Fcovariates)
DM_fixed <- vector("list", length(Flist))
DM_random <- vector("list", length(Flist))
pars_random <- character()
pars_fixed <- character()
g_random <- numeric()
g_fixed <- numeric()
uniques_in_group <- character()
names(DM_fixed) <- lapply(Flist, FUN = function(x) return(x[[2]]))
names(DM_random) <- lapply(Flist, FUN = function(x) return(x[[2]]))
for(form in Flist){
name <- form[[2]]
use <- types_and_baseForm(form)
trms <- use$terms
dataTypes <- use$types
if(length(trms) > 0){ # More than just an intercept
Xs = lapply(trms, function(trm, data, dataTypes) {
oneDM(trm, data = ddata, dataTypes = dataTypes)
}, data = ddata, dataTypes = dataTypes)
DM <- sepFixRandom(Xs, use$types)
par_names_curr <- get_parNames(DM$fixed,DM$random, as.character(name))
colnames(DM$fixed) <- par_names_curr$fixed
colnames(DM$random) <- par_names_curr$random
g <- getGMap(DM, trms, g_fixed, g_random, use$is_nested)
DM_random[[name]] <- DM$random
DM_fixed[[name]] <- DM$fixed
g_random <- c(g_random, g$random)
g_fixed <- c(g_fixed, g$fixed)
uniques_in_group <- c(uniques_in_group, par_names_curr$uniques_in_group)
pars_fixed <- c(pars_fixed, par_names_curr$fixed)
pars_random <- c(pars_random, par_names_curr$random)
} else{
pars_fixed <- c(pars_fixed, as.character(name)) # Intercept only
intercept <- as.matrix(rep(1, nrow(ddata)))
colnames(intercept) <- as.character(name)
DM_fixed[[name]] <- intercept
if(length(g_fixed) > 0){
g_fixed <- c(g_fixed, max(g_fixed) + 1)
} else{
g_fixed <- 1
}
}
}
if (report_p_vector) {
cat("fixed : \n")
cat(pars_fixed, "\n\n")
cat("random per subject : \n")
cat(uniques_in_group)
}
design <- list(
DM_fixed = DM_fixed,
DM_random = DM_random,
constants = constants,
model = model,
Fcovariates = Fcovariates
)
attr(design, "p_vector_fixed") <- pars_fixed[!pars_fixed %in% names(constants)]
attr(design, "p_vector_random") <- pars_random[!pars_random %in% names(constants)]
attr(design, "g_fixed") <- g_fixed
attr(design, "g_random") <- g_random
return(design)
}
form <- list(v~cond + (cond|group/subjects),sv~
1,B~1 + (1|group),A~1,t0~ cond + (cond|subjects))
debug(make_design_lm)
test <- make_design_lm(form, ddata = df, model = ddmTZD)
debug(getGMap)
as.numeric(as.factor(names_fixed))
max(g_fixed)
debug(getGMap)
test <- make_design_lm(form, ddata = df, model = ddmTZD)
rm(list = ls())
devtools::load_all()
source("test_files/utils_lm.R")
library(lme4)
library(BayesFactor)
n_subjects <- 6
n_cond <- 3
n_trials <- 100
n_groups <- 2
subject <- rep(1:n_subjects, each = n_trials*n_cond)
cond <- rep(rep(1:n_cond, n_subjects), each = n_trials)
rt <- rnorm(n_subjects * n_trials * n_cond, mean = cond*subject)
df <- data.frame(subjects = subject, cond = cond, rt = rt)
for(i in 2:n_groups){
new_df <- df
new_df$subjects <- new_df$subjects +n_subjects
df <- rbind(df, new_df)
}
df$group <- rep(1:n_groups, each = n_trials*n_cond*n_subjects)
df$subjects <- as.factor(df$subjects)
df$cond <- as.factor(df$cond)
df$group <- as.factor(df$group)
df$R <- as.factor(1)
make_design_lm <- function(Flist,matchfun=NULL,constants=NULL,report_p_vector=TRUE, ddata = NULL, model){
# This will reorder the data for computational purposes! The design matrices will be on the reordered data.
if(is.null(ddata)){
stop("For now, ddata has to be specified in type lm")
}
all_vars <- unique(unlist(lapply(form, FUN = function(x) all.vars(delete.response(terms(x))))))
df_covs <- sapply(df, is.factor)
df_covs <- df_covs[!df_covs]
Fcovariates <- all_vars[!all_vars %in% c("subjects", "RT", "R") & all_vars %in% df_covs]
if(length(Fcovariates == 0)) Fcovariates <- NULL
ddata <- add_accumulators(ddata, matchfun = matchfun, type = model()$type, Fcovariates = Fcovariates)
DM_fixed <- vector("list", length(Flist))
DM_random <- vector("list", length(Flist))
pars_random <- character()
pars_fixed <- character()
g_random <- numeric()
g_fixed <- numeric()
uniques_in_group <- character()
names(DM_fixed) <- lapply(Flist, FUN = function(x) return(x[[2]]))
names(DM_random) <- lapply(Flist, FUN = function(x) return(x[[2]]))
for(form in Flist){
name <- form[[2]]
use <- types_and_baseForm(form)
trms <- use$terms
dataTypes <- use$types
if(length(trms) > 0){ # More than just an intercept
Xs = lapply(trms, function(trm, data, dataTypes) {
oneDM(trm, data = ddata, dataTypes = dataTypes)
}, data = ddata, dataTypes = dataTypes)
DM <- sepFixRandom(Xs, use$types)
par_names_curr <- get_parNames(DM$fixed,DM$random, as.character(name))
colnames(DM$fixed) <- par_names_curr$fixed
colnames(DM$random) <- par_names_curr$random
g <- getGMap(DM, g_fixed, g_random, use$is_nested, ddata)
DM_random[[name]] <- DM$random
DM_fixed[[name]] <- DM$fixed
g_random <- c(g_random, g$random)
g_fixed <- c(g_fixed, g$fixed)
uniques_in_group <- c(uniques_in_group, par_names_curr$uniques_in_group)
pars_fixed <- c(pars_fixed, par_names_curr$fixed)
pars_random <- c(pars_random, par_names_curr$random)
} else{
pars_fixed <- c(pars_fixed, as.character(name)) # Intercept only
intercept <- as.matrix(rep(1, nrow(ddata)))
colnames(intercept) <- as.character(name)
DM_fixed[[name]] <- intercept
if(length(g_fixed) > 0){
g_fixed <- c(g_fixed, max(g_fixed) + 1)
} else{
g_fixed <- 1
}
}
}
if (report_p_vector) {
cat("fixed : \n")
cat(pars_fixed, "\n\n")
cat("random per subject : \n")
cat(uniques_in_group)
}
design <- list(
DM_fixed = DM_fixed,
DM_random = DM_random,
constants = constants,
model = model,
Fcovariates = Fcovariates
)
attr(design, "p_vector_fixed") <- pars_fixed[!pars_fixed %in% names(constants)]
attr(design, "p_vector_random") <- pars_random[!pars_random %in% names(constants)]
attr(design, "g_fixed") <- g_fixed
attr(design, "g_random") <- g_random
return(design)
}
form <- list(v~cond + (cond|group/subjects),sv~
1,B~1 + (1|group),A~1,t0~ cond + (cond|subjects))
debug(getGMap)
test <- make_design_lm(form, ddata = df, model = ddmTZD)
rm(list = ls())
devtools::load_all()
source("test_files/utils_lm.R")
library(lme4)
library(BayesFactor)
n_subjects <- 6
n_cond <- 3
n_trials <- 100
n_groups <- 2
subject <- rep(1:n_subjects, each = n_trials*n_cond)
cond <- rep(rep(1:n_cond, n_subjects), each = n_trials)
rt <- rnorm(n_subjects * n_trials * n_cond, mean = cond*subject)
df <- data.frame(subjects = subject, cond = cond, rt = rt)
for(i in 2:n_groups){
new_df <- df
new_df$subjects <- new_df$subjects +n_subjects
df <- rbind(df, new_df)
}
df$group <- rep(1:n_groups, each = n_trials*n_cond*n_subjects)
df$subjects <- as.factor(df$subjects)
df$cond <- as.factor(df$cond)
df$group <- as.factor(df$group)
df$R <- as.factor(1)
make_design_lm <- function(Flist,matchfun=NULL,constants=NULL,report_p_vector=TRUE, ddata = NULL, model){
# This will reorder the data for computational purposes! The design matrices will be on the reordered data.
if(is.null(ddata)){
stop("For now, ddata has to be specified in type lm")
}
all_vars <- unique(unlist(lapply(form, FUN = function(x) all.vars(delete.response(terms(x))))))
df_covs <- sapply(df, is.factor)
df_covs <- df_covs[!df_covs]
Fcovariates <- all_vars[!all_vars %in% c("subjects", "RT", "R") & all_vars %in% df_covs]
if(length(Fcovariates == 0)) Fcovariates <- NULL
ddata <- add_accumulators(ddata, matchfun = matchfun, type = model()$type, Fcovariates = Fcovariates)
DM_fixed <- vector("list", length(Flist))
DM_random <- vector("list", length(Flist))
pars_random <- character()
pars_fixed <- character()
g_random <- numeric()
g_fixed <- numeric()
uniques_in_group <- character()
names(DM_fixed) <- lapply(Flist, FUN = function(x) return(x[[2]]))
names(DM_random) <- lapply(Flist, FUN = function(x) return(x[[2]]))
for(form in Flist){
name <- form[[2]]
use <- types_and_baseForm(form)
trms <- use$terms
dataTypes <- use$types
if(length(trms) > 0){ # More than just an intercept
Xs = lapply(trms, function(trm, data, dataTypes) {
oneDM(trm, data = ddata, dataTypes = dataTypes)
}, data = ddata, dataTypes = dataTypes)
DM <- sepFixRandom(Xs, use$types)
par_names_curr <- get_parNames(DM$fixed,DM$random, as.character(name))
colnames(DM$fixed) <- par_names_curr$fixed
colnames(DM$random) <- par_names_curr$random
g <- getGMap(DM, g_fixed, g_random, use$is_nested, ddata)
DM_random[[name]] <- DM$random
DM_fixed[[name]] <- DM$fixed
g_random <- c(g_random, g$random)
g_fixed <- c(g_fixed, g$fixed)
uniques_in_group <- c(uniques_in_group, par_names_curr$uniques_in_group)
pars_fixed <- c(pars_fixed, par_names_curr$fixed)
pars_random <- c(pars_random, par_names_curr$random)
} else{
pars_fixed <- c(pars_fixed, as.character(name)) # Intercept only
intercept <- as.matrix(rep(1, nrow(ddata)))
colnames(intercept) <- as.character(name)
DM_fixed[[name]] <- intercept
if(length(g_fixed) > 0){
g_fixed <- c(g_fixed, max(g_fixed) + 1)
} else{
g_fixed <- 1
}
}
}
if (report_p_vector) {
cat("fixed : \n")
cat(pars_fixed, "\n\n")
cat("random per subject : \n")
cat(uniques_in_group)
}
design <- list(
DM_fixed = DM_fixed,
DM_random = DM_random,
constants = constants,
model = model,
Fcovariates = Fcovariates
)
attr(design, "p_vector_fixed") <- pars_fixed[!pars_fixed %in% names(constants)]
attr(design, "p_vector_random") <- pars_random[!pars_random %in% names(constants)]
attr(design, "g_fixed") <- g_fixed
attr(design, "g_random") <- g_random
return(design)
}
form <- list(v~cond + (cond|group/subjects),sv~
1,B~1 + (1|group),A~1,t0~ cond + (cond|subjects))
debug(getGMap)
test <- make_design_lm(form, ddata = df, model = ddmTZD)
terms
terms
terms[!terms %in% names_fixed]
names_fixed
load("/home/niek/Downloads/Data/Accumulationlines.RData")
X
