}
form <- list(v~cond + (cond|subjects), a~1+ (1|subjects), t0 ~ 1 + (1|subjects),
Z ~ 1 + (1|subjects), s ~1, DP ~ 1, SZ ~ 1, sv ~1, st0 ~ 1)
# NAs in slope mean are treated as 0!!
design <- make_design_lm(form, ddata = dat_coh, model = ddmTZD,
constants = c(sv = log(0), s = log(1), st0 = log(0), DP = qnorm(.5),
SZ = qnorm(0), st0 = log(0)))
samplers <- make_samplers_lm(dat_coh, design)
# Things to do:
# Check whether replacing NAs with 0 is alright for DMs
# Check the adding of between variables out of the random variables in get_conditionals (happens with nesting)!!!!
# Finding which are intercepts with 0 + in pmwgs$is_intercept
source("test_files/sampling_lm.R")
samplers <- auto_burn(samplers, verbose = T,cores_per_chain = 4)
rm(list = ls())
devtools::load_all()
load("~/Documents/UVA/2023/BetweenSubsApplications/Manning2022/Manning2022.RData")
data <- data[as.numeric(data$subjects) %% 2 != 0,]
source("test_files/sampling_lm.R")
source("test_files/helps_lm.R")
source("test_files/utils_lm.R")
# Remove NULL responses
data <- data[data$keypress != 0,]
data$keypress[data$keypress == 1] <- "left"
data$keypress[data$keypress == 2] <- "right"
colnames(data)[c(5,6,7)] <- c("R", "rt", "subjects")
data$R <- factor(data$R)
data$subjects <- factor(data$subjects)
data$cond <- factor(data$cond)
data$group <- factor(data$group)
aggregate(EEG_respslope ~ cond, data = data, FUN = mean)
dat_coh <- data[data$task == "coherence",]
dat_coh$slope_mean <- NA
dat_coh$slope_diff <- NA
for(sub in unique(dat_coh$subjects)){
idx <- dat_coh$subjects == sub
mean_sub <- mean(dat_coh$EEG_respslope[idx])
diff_sub <- 2*(dat_coh$EEG_respslope[dat_coh$cond == "easy"][idx][1] - mean_sub)
dat_coh$slope_mean[idx] <- mean_sub
dat_coh$slope_diff[idx] <- diff_sub
}
form <- list(v~cond + (cond|subjects), a~1+ (1|subjects), t0 ~ 1 + (1|subjects),
Z ~ 1 + (1|subjects), s ~1, DP ~ 1, SZ ~ 1, sv ~1, st0 ~ 1)
# NAs in slope mean are treated as 0!!
design <- make_design_lm(form, ddata = dat_coh, model = ddmTZD,
constants = c(sv = log(0), s = log(1), st0 = log(0), DP = qnorm(.5),
SZ = qnorm(0), st0 = log(0)))
samplers <- make_samplers_lm(dat_coh, design)
# Things to do:
# Check whether replacing NAs with 0 is alright for DMs
# Check the adding of between variables out of the random variables in get_conditionals (happens with nesting)!!!!
# Finding which are intercepts with 0 + in pmwgs$is_intercept
source("test_files/sampling_lm.R")
samplers <- auto_burn(samplers, verbose = T,cores_per_chain = 4)
source("test_files/sampling_lm.R")
source("test_files/helps_lm.R")
source("test_files/utils_lm.R")
samplers <- run_adapt(samplers, verbose = T, cores_per_chain = 4, cores_for_chains = 3, particle_factor = 30)
debug(test_adapted)
samplers <- run_adapt(samplers, verbose = T, cores_per_chain = 4, cores_for_chains = 3, particle_factor = 30)
samplers <- run_adapt(samplers, verbose = T, cores_per_chain = 4, cores_for_chains = 3, particle_factor = 30, step_size = 25,
min_unique = 25)
debug(test_adapted_lm)
samplers <- run_adapt(samplers, verbose = T, cores_per_chain = 4, cores_for_chains = 3, particle_factor = 30, step_size = 25,
min_unique = 25)
auto_mclapply(X = samples$subjects,FUN = get_conditionals_lm,samples = test_samples,
mc.cores = n_cores_conditional)
auto_mclapply(X = samples$subjects,FUN = get_conditionals_lm,samples = test_samples,
mc.cores = n_cores_conditional)
debug(get_conditionals_lm)
n_cores_conditional = 1
auto_mclapply(X = samples$subjects,FUN = get_conditionals_lm,samples = test_samples,
mc.cores = n_cores_conditional)
condMVN(mean = mu_tilde, sigma = var_tilde,
dependent.ind = 1:n_pars, given.ind = (n_pars + 1):length(mu_tilde),
X.given = c(samples$fixed[,iteration], samples$g_random[g_random_idx,iteration], samples$g_fixed[,iteration]))
test <- condMVN(mean = mu_tilde, sigma = var_tilde,
dependent.ind = 1:n_pars, given.ind = (n_pars + 1):length(mu_tilde),
X.given = c(samples$fixed[,iteration], samples$g_random[g_random_idx,iteration], samples$g_fixed[,iteration]))
cov2cor(test$condVar)
source("test_files/sampling_lm.R")
source("test_files/helps_lm.R")
source("test_files/utils_lm.R")
samplers <- run_adapt(samplers, verbose = T, cores_per_chain = 4, cores_for_chains = 3, particle_factor = 30)
undebug(test_adapted_lm)
samplers <- run_adapt(samplers, verbose = T, cores_per_chain = 4, cores_for_chains = 3, particle_factor = 30)
samplers <- run_sample(samplers, verbose = T, cores_per_chain = 4, cores_for_chains = 3, iter = 700)
source("test_files/sampling_lm.R")
source("test_files/helps_lm.R")
source("test_files/utils_lm.R")
samplers <- run_sample(samplers, verbose = T, cores_per_chain = 4, cores_for_chains = 3, iter = 700)
cor(t(samplers[[1]]$samples$random[get_sub_idx("01", samplers[[1]]$pars_random)]))
cor((samplers[[1]]$samples$random[get_sub_idx("01", samplers[[1]]$pars_random)]))
cor((samplers[[1]]$samples$random[get_sub_idx("01", samplers[[1]]$pars_random),]))
cor(t(samplers[[1]]$samples$random[get_sub_idx("01", samplers[[1]]$pars_random),]))
cor(t(samplers[[1]]$samples$random[get_sub_idx("02", samplers[[1]]$pars_random),]))
cor(t(samplers[[1]]$samples$random[get_sub_idx("03", samplers[[1]]$pars_random),]))
cor(t(samplers[[1]]$samples$fixed))
cor(cbind(t(samplers[[1]]$samples$fixed), t(samplers[[1]]$samples$random[get_sub_idx("03", samplers[[1]]$pars_random),]))
)
test <- cor(cbind(t(samplers[[1]]$samples$fixed), t(samplers[[1]]$samples$random[get_sub_idx("03", samplers[[1]]$pars_random),])))
corrplot::corrplot(test)
test <- cor(cbind(t(samplers[[1]]$samples$fixed), t(samplers[[1]]$samples$random[get_sub_idx("01", samplers[[1]]$pars_random),])))
corrplot::corrplot(test)
test <- cor(cbind(t(samplers[[1]]$samples$fixed), t(samplers[[1]]$samples$random[get_sub_idx("05", samplers[[1]]$pars_random),])))
corrplot::corrplot(test)
test <- cor(t(samplers[[1]]$samples$random[get_sub_idx("03", samplers[[1]]$pars_random),])), t(samplers[[1]]$samples$random[get_sub_idx("05", samplers[[1]]$pars_random),])))
test <- cor(t(samplers[[1]]$samples$random[get_sub_idx("03", samplers[[1]]$pars_random),]), t(samplers[[1]]$samples$random[get_sub_idx("05", samplers[[1]]$pars_random),])))
test <- cor(t(samplers[[1]]$samples$random[get_sub_idx("03", samplers[[1]]$pars_random),]), t(samplers[[1]]$samples$random[get_sub_idx("05", samplers[[1]]$pars_random),])))
test <- cor(cbind(t(samplers[[1]]$samples$random[get_sub_idx("03", samplers[[1]]$pars_random),]), t(samplers[[1]]$samples$random[get_sub_idx("05", samplers[[1]]$pars_random),])))
corrplot::corrplot(test)
real <- rnorm(5)
logs <- log(real)
n_pars <- 5
real <- abs(rnorm(n_pars))
logs <- log(real)
n_pars <- 5
real <- abs(rnorm(n_pars))
logs <- log(real)
2^n_pars * prod(real^(n_pars + 1))
n_pars <- 5
real <- abs(rnorm(n_pars))
exps <- exp(real)
2^n_pars * prod(real^(n_pars + 1))
log(2^n_pars) + sum((n_pars + 1)*log(diag(exps))))
prod(1:4)
n_pars <- 5
real <- abs(rnorm(n_pars))
exps <- exp(real)
2^n_pars * prod(real^(n_pars + 1))
log(2^n_pars) + sum((n_pars + 1)*log(exps))
n_pars <- 5
real <- abs(rnorm(n_pars))
exps <- exp(real)
2^n_pars * prod(real^(n_pars + 1))
log(2^n_pars) + (n_pars + 1)*sum(log(exps))
set.seed(123)
n_pars <- 5
real <- abs(rnorm(n_pars))
exps <- exp(real)
2^n_pars * prod(real^(n_pars + 1))
log(2^n_pars) + (n_pars + 1)*sum(log(exps))
set.seed(123)
n_pars <- 5
real <- abs(rnorm(n_pars))
exps <- exp(real)
2^n_pars * prod(real^(n_pars + 1))
log(2^n_pars) + (n_pars + 1)*sum(log(exps))
set.seed(123)
n_pars <- 5
real <- abs(rnorm(n_pars))
exps <- exp(real)
2^n_pars * prod(real^(n_pars + 1))
log(2^n_pars) + (n_pars + 1)*sum(log(exps))
set.seed(123)
n_pars <- 5
real <- abs(rnorm(n_pars))
exps <- exp(real)
2^n_pars * prod(real^(n_pars + 1))
log(2^n_pars) + sum((n_pars + 1)*(log(exps)))
set.seed(123)
n_pars <- 5
real <- abs(rnorm(n_pars))
exps <- exp(real)
2^n_pars * prod(real^(n_pars + 1))
log(2^n_pars) + sum((n_pars + 1)*(log(exps)))
set.seed(123)
n_pars <- 5
real <- abs(rnorm(n_pars))
exps <- exp(real)
exp(2^n_pars * prod(real^(n_pars + 1)))
log(2^n_pars) + sum((n_pars + 1)*(log(exps)))
set.seed(123)
n_pars <- 5
real <- abs(rnorm(n_pars))
exps <- exp(real)
exp(2^n_pars * prod(real^(n_pars + 1)))
log(2^n_pars) + sum((n_pars + 1)*(log(exps)))
set.seed(123)
n_pars <- 5
real <- abs(rnorm(n_pars))
exps <- exp(real)
exp(2^n_pars * prod(real^(n_pars + 1)))
log(2^n_pars) + sum((n_pars + 1)*(log(exps)))
set.seed(123)
n_pars <- 5
real <- abs(rnorm(n_pars))
exps <- exp(real)
exp(2^n_pars * prod(real^(n_pars + 1)))
log(2^n_pars) + sum((n_pars + 1)*(log(exps)))
real^(n_pars + 1)
set.seed(123)
n_pars <- 5
real <- abs(rnorm(n_pars))
exps <- exp(real)
2^n_pars * prod(exps^(n_pars + 1))
log(2^n_pars) + sum((n_pars + 1)*(log(exps)))
set.seed(123)
n_pars <- 5
logs <- abs(rnorm(n_pars))
exps <- exp(real)
2^n_pars * prod(logs^(n_pars + 1))
log(2^n_pars) + sum((n_pars + 1)*(log(exps)))
set.seed(123)
n_pars <- 5
logs <- abs(rnorm(n_pars))
exps <- exp(real)
2^n_pars * prod(logs^(n_pars + 1))
log(2^n_pars) + sum((n_pars + 1)*(log(exps)))
set.seed(123)
n_pars <- 5
logs <- abs(rnorm(n_pars))
exps <- exp(real)
2^n_pars * prod(logs^(n_pars + 1))
log(2^n_pars) + sum((n_pars + 1)*(log(exps)))
seqs <- n_pars - 1:n_pars + 1
log(2^n_pars) + sum(seqs * logs)
2^n_pars * prod(exps^(n_pars + 1))
log(2^n_pars * prod(exps^(n_pars + 1)))
set.seed(123)
n_pars <- 5
logs <- abs(rnorm(n_pars))
exps <- exp(real)
log(2^n_pars * prod(exps^(n_pars + 1)))
log(2^n_pars) + sum((n_pars + 1)*(log(exps)))
seqs <- n_pars - 1:n_pars + 1
log(2^n_pars) + sum(seqs * logs)
rm(list=ls())
print(load("test_files/PNAS.RData"))
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
head(dat)
# NB: This data has been truncated at 0.25s and 1.5s
# Average rate = intercept, and rate d = difference (match-mismatch) contrast
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
design_B <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Flist=list(v~lM,sv~1,B~1,A~1,t0~1),
constants=c(sv=log(1)),
model=lbaB)
rm(list=ls())
devtools::load_all()
print(load("test_files/PNAS.RData"))
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
head(dat)
# NB: This data has been truncated at 0.25s and 1.5s
# Average rate = intercept, and rate d = difference (match-mismatch) contrast
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
design_B <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Flist=list(v~lM,sv~1,B~1,A~1,t0~1),
constants=c(sv=log(1)),
model=lbaB)
p_vector <- sampled_p_vector(design_B)
p_vector[1:length(p_vector)] <- abs(rnorm(length(p_vector)))
mapped_par(p_vector, design_B)
# prior <- get_prior_single(design = design_B)
# plot_prior(prior)
prior <- list(
theta_mu_mean = 1:7,
theta_mu_var = diag(c(7:1))
) # This way we're using default priors for the nuisance parameters
dat2 <- dat[dat$subjects %in% unique(dat$subjects)[1:4],]
dat2$subjects <- droplevels(dat2$subjects)
# Nuisance non hyper = non hierarchically estimated parameters
samplers_test <- make_samplers(dat2, design_B)
samplers_test <- run_emc(samplers_test)
samplers_test <- run_emc(samplers_test, cores_for_chains = 1)
rm(list=ls())
devtools::load_all()
print(load("test_files/PNAS.RData"))
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
head(dat)
# Average rate = intercept, and rate d = difference (match-mismatch) contrast
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
design_B <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Flist=list(v~lM,sv~1,B~1,A~1,t0~1),
constants=c(sv=log(1)),
model=lbaB)
remove.packages("EMC2")
.rs.restartR()
install.packages("EMC2")
devtools::install()
rm(list=ls())
devtools::load_all()
print(load("test_files/PNAS.RData"))
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
head(dat)
# NB: This data has been truncated at 0.25s and 1.5s
# Average rate = intercept, and rate d = difference (match-mismatch) contrast
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
design_B <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Flist=list(v~lM,sv~1,B~1,A~1,t0~1),
constants=c(sv=log(1)),
model=lbaB)
p_vector <- sampled_p_vector(design_B)
p_vector[1:length(p_vector)] <- abs(rnorm(length(p_vector)))
mapped_par(p_vector, design_B)
# prior <- get_prior_single(design = design_B)
# plot_prior(prior)
prior <- list(
theta_mu_mean = 1:7,
theta_mu_var = diag(c(7:1))
) # This way we're using default priors for the nuisance parameters
dat2 <- dat[dat$subjects %in% unique(dat$subjects)[1:4],]
dat2$subjects <- droplevels(dat2$subjects)
# Nuisance non hyper = non hierarchically estimated parameters
samplers_test <- make_samplers(dat2, design_B)
samplers_test <- run_emc(samplers_test, cores_for_chains = 1)
rm(list=ls())
library(EMC2)
print(load("test_files/PNAS.RData"))
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
head(dat)
# NB: This data has been truncated at 0.25s and 1.5s
# Average rate = intercept, and rate d = difference (match-mismatch) contrast
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
design_B <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Flist=list(v~lM,sv~1,B~1,A~1,t0~1),
constants=c(sv=log(1)),
model=lbaB)
p_vector <- sampled_p_vector(design_B)
p_vector[1:length(p_vector)] <- abs(rnorm(length(p_vector)))
mapped_par(p_vector, design_B)
# prior <- get_prior_single(design = design_B)
# plot_prior(prior)
prior <- list(
theta_mu_mean = 1:7,
theta_mu_var = diag(c(7:1))
) # This way we're using default priors for the nuisance parameters
dat2 <- dat[dat$subjects %in% unique(dat$subjects)[1:4],]
dat2$subjects <- droplevels(dat2$subjects)
# Nuisance non hyper = non hierarchically estimated parameters
samplers_test <- make_samplers(dat2, design_B)
samplers_test <- run_emc(samplers_test, cores_for_chains = 1)
EMC2:::`_EMC2_calc_ll`
rm(list=ls())
library(EMC2)
print(load("test_files/PNAS.RData"))
dat <- data[,c("s","E","S","R","RT")]
names(dat)[c(1,5)] <- c("subjects","rt")
levels(dat$R) <- levels(dat$S)
head(dat)
# NB: This data has been truncated at 0.25s and 1.5s
# Average rate = intercept, and rate d = difference (match-mismatch) contrast
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
ADmat
Emat <- matrix(c(0,-1,0,0,0,-1),nrow=3)
dimnames(Emat) <- list(NULL,c("a-n","a-s"))
Emat
design_B <- make_design(
Ffactors=list(subjects=levels(dat$subjects),S=levels(dat$S),E=levels(dat$E)),
Rlevels=levels(dat$R),matchfun=function(d)d$S==d$lR,
Flist=list(v~lM,sv~1,B~1,A~1,t0~1),
constants=c(sv=log(1)),
model=lbaB)
p_vector <- sampled_p_vector(design_B)
p_vector[1:length(p_vector)] <- abs(rnorm(length(p_vector)))
mapped_par(p_vector, design_B)
# prior <- get_prior_single(design = design_B)
# plot_prior(prior)
prior <- list(
theta_mu_mean = 1:5,
theta_mu_var = diag(c(5:1))
) # This way we're using default priors for the nuisance parameters
dat2 <- dat[dat$subjects %in% unique(dat$subjects)[1:4],]
dat2$subjects <- droplevels(dat2$subjects)
# Nuisance non hyper = non hierarchically estimated parameters
samplers_test <- make_samplers(dat2, design_B, type = "single")
samplers_test <- run_emc(samplers_test, cores_per_chain = 4, verbose = T)
EMC2:::run_bridge_sampling(samplers_test, n_cores = 1)
attr(samplers[[1]],"variant_funs")
attr(samplers_test[[1]],"variant_funs")
attr(samplers[[1]], "variant_funs") <- EMC2:::get_variant_funs("single")
EMC2:::run_bridge_sampling(samplers_test, n_cores = 1)
attr(samplers_test[[1]], "variant_funs") <- EMC2:::get_variant_funs("single")
EMC2:::run_bridge_sampling(samplers_test, n_cores = 1)
debug(EMC2:::bridge_sampling)
EMC2:::run_bridge_sampling(samplers_test, n_cores = 1)
EMC2:::run_bridge_sampling(samplers_test, n_cores = 1)
variant_funs$add_info()
variant_funs$add_info
devtools::load_all()
attr(samplers_test[[1]], "variant_funs") <- EMC2:::get_variant_funs("single")
debug(EMC2:::bridge_sampling)
EMC2:::run_bridge_sampling(samplers_test, n_cores = 1)
variant_funs$bridge_add_info()
qList
tmp
devtools::load_all()
attr(samplers_test[[1]], "variant_funs") <- EMC2:::get_variant_funs("single")
debug(EMC2:::h.unnormalized.posterior)
EMC2:::run_bridge_sampling(samplers_test, n_cores = 1)
lws
lw
devtools::load_all()
attr(samplers_test[[1]], "variant_funs") <- EMC2:::get_variant_funs("single")
EMC2:::run_bridge_sampling(samplers_test, n_cores = 1)
debug(EMC2:::bridge_sampling)
EMC2:::run_bridge_sampling(samplers_test, n_cores = 1)
qList
debug(eval.unnormalized.posterior)
eval.unnormalized.posterior(samples_iter = samples_iter, gen_samples = gen_samples,
data = data, m = m, L =L, info = info, n_cores = n_cores)
debug(h.unnormalized.posterior)
lws
devtools::load_all()
attr(samplers_test[[1]], "variant_funs") <- EMC2:::get_variant_funs("single")
debug(EMC2:::bridge_sampling)
EMC2:::run_bridge_sampling(samplers_test, n_cores = 1)
.rs.restartR()
EMC2:::run_bridge_sampling(samplers_test, n_cores = 1)
devtools::load_all()
EMC2:::run_bridge_sampling(samplers_test, n_cores = 1)
EMC2:::run_bridge_sampling(samplers_test, n_cores = 1)
EMC2:::run_bridge_sampling(samplers_test, n_cores = 1)
load("~/Documents/UVA/2023/BridgeSampling/EMC_version_betterPrior.RData")
devtools::load_all()
attr(samplers[[1]], "variant_funs") <- EMC2:::get_variant_funs("diagonal")
EMC2:::run_bridge_sampling(samplers_test, n_cores = 1)
EMC2:::run_bridge_sampling(samplers, n_cores = 1)
load("~/Documents/UVA/2023/BridgeSampling/EMC_version.RData")
EMC2:::run_bridge_sampling(samplers, n_cores = 1)
attr(samplers[[1]], "variant_funs") <- EMC2:::get_variant_funs("diagonal")
EMC2:::run_bridge_sampling(samplers, n_cores = 1)
microbenchmark::microbenchmark(
EMC2:::run_bridge_sampling(samplers_test, n_cores = 1),
EMC2:::run_bridge_sampling(samplers_test, n_cores = 8), times = 3
)
microbenchmark::microbenchmark(
EMC2:::run_bridge_sampling(samplers, n_cores = 1),
EMC2:::run_bridge_sampling(samplers, n_cores = 8), times = 3
)
EMC2:::run_bridge_sampling(samplers, n_cores = 8)
devtools::load_all()
attr(samplers[[1]], "variant_funs") <- EMC2:::get_variant_funs("diagonal")
debug(eval.unnormalized.posterior)
EMC2:::run_bridge_sampling(samplers, n_cores = 8)
mls
devtools::load_all()
microbenchmark::microbenchmark(
EMC2:::run_bridge_sampling(samplers, n_cores = 1),
EMC2:::run_bridge_sampling(samplers, n_cores = 2), times = 3
)
devtools::load_all()
attr(samplers[[1]], "variant_funs") <- EMC2:::get_variant_funs("diagonal")
microbenchmark::microbenchmark(
EMC2:::run_bridge_sampling(samplers, n_cores = 1),
EMC2:::run_bridge_sampling(samplers, n_cores = 2), times = 3
)
devtools::load_all()
devtools::load_all()
attr(samplers[[1]], "variant_funs") <- EMC2:::get_variant_funs("diagonal")
debug(eval.unnormalized.posterior)
devtools::load_all()
devtools::load_all()
EMC2:::run_bridge_sampling(samplers, n_cores = 2)
EMC2:::run_bridge_sampling(samplers, cores_per_prop = 2)
microbenchmark::microbenchmark(
EMC2:::run_bridge_sampling(samplers, cores_per_prop = 2, cores_for_props = 4),
EMC2:::run_bridge_sampling(samplers, cores_per_prop = 8, cores_for_props = 1), times = 5
)
debug(eval.unnormalized.posterior)
EMC2:::run_bridge_sampling(samplers, cores_per_prop = 2)
cores_per_prop
cores_for_props
microbenchmark::microbenchmark(
EMC2:::run_bridge_sampling(samplers, cores_per_prop = 4, cores_for_props = 2),
EMC2:::run_bridge_sampling(samplers, cores_per_prop = 4, cores_for_props = 1), times = 5
)
undebug(eval.unnormalized.posterior)
microbenchmark::microbenchmark(
EMC2:::run_bridge_sampling(samplers, cores_per_prop = 4, cores_for_props = 2),
EMC2:::run_bridge_sampling(samplers, cores_per_prop = 4, cores_for_props = 1), times = 5
)
