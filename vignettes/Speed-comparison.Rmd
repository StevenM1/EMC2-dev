---
title: "Speed comparison"
description: "A small comparison of the speed of EMC2 compared to Stan"
author: "Niek Stevenson"
output: rmarkdown::html_document
bibliography: refs.bib
vignette: >
  %\VignetteIndexEntry{"Speed-comparison"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
rm(list = ls())
library(EMC2)
```

## Introduction

*EMC2* boasts fast MCMC estimation of cognitive models. Here we compare the speed of *EMC2* to *Stan*. *Stan* is a popular probabilistic programming language for Bayesian modeling, and is known for its powerful Hamiltonian Monte Carlo (HMC) sampler [@carpenter2017stan]. We will use the DDM model to compare the two software packages.

First we load the necessary packages and clear the workspace.

```{r, results = "hide"}
rm(list = ls())
library(EMC2)
library(cmdstanr)

# If you don't have cmdstanr installed, uncomment and run the following line
# install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
```

### Set-up

We will generate several datasets using *EMC2*, and fit the data using the same model in *Stan* and *EMC2*. We will use a five, six and seven parameter Diffusion Decision Model (DDM) (see ?DDM for more details) to compare the two software packages. The designs are specified using the `design` function and will be used to generate the data.

```{r}
rm(list=ls())
library(EMC2)
set.seed(123)
design_DDM5 <- design(factors=list(subjects=1,C=c("HARD", "EASY")),
                      Rlevels = c(0, 1),
                      formula =list(v~0+C,a~1, t0~1, s~1, Z~1, sv~1),
                      constants=c(s=log(1)),
                      model = DDM)

prior_DDM5 <- prior(design_DDM5)
plot_prior(prior_DDM5, design=design_DDM5)

pmean <- sampled_p_vector(design_DDM5, doMap = F)
pmean[] <- c(1.5, 1.6, log(1), log(.435), qnorm(.5), log(1))

DDM5dat <- make_data(pmean,design_DDM5,n_trials = 50)
plot_defective_density(DDM5dat)
save(design_DDM5, pmean, DDM5dat, file = "DDM5.RData")

design_DDM6 <- design(factors=list(subjects=1,C=c("HARD", "EASY")),
                      Rlevels = c(0, 1),
                      formula =list(v~0+C,a~1, t0~1, s~1, Z~1, sv~1, SZ~1),
                      constants=c(s=log(1)),
                      model = DDM)

pmean <- sampled_p_vector(design_DDM6, doMap = F)
pmean[] <- c(1.5, 1.6, log(1), log(.435), qnorm(.5), log(1), qnorm(.25))
DDM6dat <- make_data(pmean,design_DDM6, n_trials = 50)
plot_defective_density(DDM6dat)
save(design_DDM6, pmean, DDM6dat, file = "DDM6.RData")

design_DDM7 <- design(factors=list(subjects=1,C=c("HARD", "EASY")),
                      Rlevels = c(0, 1),
                      formula =list(v~0+C,a~1, t0~1, s~1, Z~1, sv~1, SZ~1, st0 ~ 1),
                      constants=c(s=log(1)),
                      model = DDM)

pmean <- sampled_p_vector(design_DDM7, doMap = F)
pmean[] <- c(1.5, 1.6, log(1), log(.435), qnorm(.5), log(1), qnorm(.25), log(.183))
DDM7dat <- make_data(pmean,design_DDM7,n_trials = 50)
plot_defective_density(DDM7dat)
save(design_DDM7, pmean, DDM7dat, file = "DDM7.RData")
```

With the generated data we can fit the data using the respective models with *EMC2* and *Stan*. Let's start with *EMC2*.

```{r, eval = FALSE}
# make EMC2 objects
DDM5 <- make_emc(DDM5dat, design_DDM5, type = "single" , compress = FALSE,  n_chains = 4)
DDM6 <- make_emc(DDM6dat, design_DDM6, type = "single", compress = FALSE, n_chains = 4)  
DDM7 <- make_emc(DDM7dat, design_DDM7, type = "single", compress = FALSE, n_chains = 4)

# fit models
DDM5 <- fit(DDM5, cores_per_chain = 8, fileName = "DDM5.RData", iter = 500)
DDM6 <- fit(DDM6, cores_per_chain = 8, fileName = "DDM6.RData", iter = 500)
DDM7 <- fit(DDM7, cores_per_chain = 8, fileName = "DDM7.RData", iter = 500)
```

All models converged without any issues. Now we can compare the speed of the EMC2 models to the Stan models. The time to fit the models is outputted in the console by EMC2. To measure the speed of the Stan models we can use the `system.time` function.

```{r}
file <- file.path("vignettes/EMC2vStan/5ddm_transformed.stan")
mod <- cmdstan_model(file)

# prepare data
standata5 <- list(N=nrow(DDM5dat), cnd = ifelse(DDM5dat$C == "HARD", 1, 2), Ncnds = length(unique(DDM5dat$C)), rt = DDM5dat$rt, resp = as.numeric(as.character(DDM5dat$R)), parallel = 0 # for parallelization --> uses reduce summation 
)

# fit the model and time it
system.time({
  fit5 <- mod$sample(data = standata5, seed = 123, chains = 4, parallel_chains = 4, refresh = 10, 
                       iter_warmup = 200, iter_sampling = 300)
})

# look at summary statistics
fit5$summary()
```

Now for model 6.

```{r}
# repeat for DDM6
file <- file.path("vignettes/EMC2vStan/6ddm_transformed.stan")
mod <- cmdstan_model(file)

# prepare data
standata6 <- list(N=nrow(DDM6dat), cnd = ifelse(DDM6dat$C == "HARD", 1, 2), Ncnds = length(unique(DDM6dat$C)), rt = DDM6dat$rt, resp = as.numeric(as.character(DDM6dat$R)), parallel = 0)

# fit the model and time it
system.time({
  fit6 <- mod$sample(data = standata6, seed = 123, chains = 4, parallel_chains = 4, refresh = 10,
                     iter_warmup = 200, iter_sampling = 300)
})

# look at summary statistics 
fit6$summary()

# repeat for DDM7
file <- file.path("vignettes/EMC2vStan/7ddm_transformed.stan")
mod <- cmdstan_model(file)

# prepare data
standata7 <- list(N=nrow(DDM7dat), cnd = ifelse(DDM7dat$C == "HARD", 1, 2), Ncnds = length(unique(DDM7dat$C)), rt = DDM7dat$rt, resp = as.numeric(as.character(DDM7dat$R)), parallel = 0)

# fit the model and time it
system.time({
  fit7 <- mod$sample(data = standata7, seed = 123, chains = 4, parallel_chains = 4, refresh = 10,
                     iter_warmup = 200, iter_sampling = 300)
})
# look at summary statistics
fit7$summary()


```
